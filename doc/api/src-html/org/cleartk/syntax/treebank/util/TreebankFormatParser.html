<HTML>
<BODY BGCOLOR="white">
<PRE>
<FONT color="green">001</FONT>    /** <a name="line.1"></a>
<FONT color="green">002</FONT>     * Copyright (c) 2007-2008, Regents of the University of Colorado <a name="line.2"></a>
<FONT color="green">003</FONT>     * All rights reserved.<a name="line.3"></a>
<FONT color="green">004</FONT>     * <a name="line.4"></a>
<FONT color="green">005</FONT>     * Redistribution and use in source and binary forms, with or without<a name="line.5"></a>
<FONT color="green">006</FONT>     * modification, are permitted provided that the following conditions are met:<a name="line.6"></a>
<FONT color="green">007</FONT>     * <a name="line.7"></a>
<FONT color="green">008</FONT>     * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. <a name="line.8"></a>
<FONT color="green">009</FONT>     * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. <a name="line.9"></a>
<FONT color="green">010</FONT>     * Neither the name of the University of Colorado at Boulder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. <a name="line.10"></a>
<FONT color="green">011</FONT>     * <a name="line.11"></a>
<FONT color="green">012</FONT>     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"<a name="line.12"></a>
<FONT color="green">013</FONT>     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE<a name="line.13"></a>
<FONT color="green">014</FONT>     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<a name="line.14"></a>
<FONT color="green">015</FONT>     * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE<a name="line.15"></a>
<FONT color="green">016</FONT>     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR<a name="line.16"></a>
<FONT color="green">017</FONT>     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF<a name="line.17"></a>
<FONT color="green">018</FONT>     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS<a name="line.18"></a>
<FONT color="green">019</FONT>     * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN<a name="line.19"></a>
<FONT color="green">020</FONT>     * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)<a name="line.20"></a>
<FONT color="green">021</FONT>     * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE<a name="line.21"></a>
<FONT color="green">022</FONT>     * POSSIBILITY OF SUCH DAMAGE. <a name="line.22"></a>
<FONT color="green">023</FONT>     */<a name="line.23"></a>
<FONT color="green">024</FONT>    package org.cleartk.syntax.treebank.util;<a name="line.24"></a>
<FONT color="green">025</FONT>    <a name="line.25"></a>
<FONT color="green">026</FONT>    import java.util.ArrayList;<a name="line.26"></a>
<FONT color="green">027</FONT>    import java.util.List;<a name="line.27"></a>
<FONT color="green">028</FONT>    import java.util.Stack;<a name="line.28"></a>
<FONT color="green">029</FONT>    import java.util.regex.Matcher;<a name="line.29"></a>
<FONT color="green">030</FONT>    import java.util.regex.Pattern;<a name="line.30"></a>
<FONT color="green">031</FONT>    <a name="line.31"></a>
<FONT color="green">032</FONT>    /**<a name="line.32"></a>
<FONT color="green">033</FONT>     * &lt;br&gt;<a name="line.33"></a>
<FONT color="green">034</FONT>     * Copyright (c) 2007-2008, Regents of the University of Colorado &lt;br&gt;<a name="line.34"></a>
<FONT color="green">035</FONT>     * All rights reserved.<a name="line.35"></a>
<FONT color="green">036</FONT>     * <a name="line.36"></a>
<FONT color="green">037</FONT>     * <a name="line.37"></a>
<FONT color="green">038</FONT>     * @author Philip Ogren<a name="line.38"></a>
<FONT color="green">039</FONT>     * <a name="line.39"></a>
<FONT color="green">040</FONT>     *         This class was written to be a stand alone parser for the Penn<a name="line.40"></a>
<FONT color="green">041</FONT>     *         Treebank data. Basically, I need a way to synch up the propbank data<a name="line.41"></a>
<FONT color="green">042</FONT>     *         with extents of plain text that are labeled. This is not possible to<a name="line.42"></a>
<FONT color="green">043</FONT>     *         do without parsing the treebank data first. The parse method will<a name="line.43"></a>
<FONT color="green">044</FONT>     *         parse a single sentence from the treebank data from e.g.<a name="line.44"></a>
<FONT color="green">045</FONT>     *         wsj/mrg/06/wsj_0656.mrg.<a name="line.45"></a>
<FONT color="green">046</FONT>     * <a name="line.46"></a>
<FONT color="green">047</FONT>     *         I initially looked at the OpenNLP treebank parser but they made a few<a name="line.47"></a>
<FONT color="green">048</FONT>     *         assumptions about they wanted to keep for the parser that would make<a name="line.48"></a>
<FONT color="green">049</FONT>     *         it difficult to align with the propbank data. See:<a name="line.49"></a>
<FONT color="green">050</FONT>     *         https://sourceforge<a name="line.50"></a>
<FONT color="green">051</FONT>     *         .net/forum/forum.php?thread_id=1751983&amp;forum_id=9943 for relevant<a name="line.51"></a>
<FONT color="green">052</FONT>     *         discussion. I looked at their parsing implementation and tried to<a name="line.52"></a>
<FONT color="green">053</FONT>     *         modify it. However, I think the code below bears little resemblance<a name="line.53"></a>
<FONT color="green">054</FONT>     *         to theirs. But there may yet be some snippets taken directly out of<a name="line.54"></a>
<FONT color="green">055</FONT>     *         that code. The two regular expressions used are very similar.<a name="line.55"></a>
<FONT color="green">056</FONT>     * <a name="line.56"></a>
<FONT color="green">057</FONT>     * @see opennlp.tools.parser.Parse#parseParse(String)<a name="line.57"></a>
<FONT color="green">058</FONT>     */<a name="line.58"></a>
<FONT color="green">059</FONT>    public class TreebankFormatParser {<a name="line.59"></a>
<FONT color="green">060</FONT>            /**<a name="line.60"></a>
<FONT color="green">061</FONT>             * used to identify tokens in Penn Treebank labeled constituents. It will<a name="line.61"></a>
<FONT color="green">062</FONT>             * match strings such as:<a name="line.62"></a>
<FONT color="green">063</FONT>             * &lt;ul&gt;<a name="line.63"></a>
<FONT color="green">064</FONT>             * &lt;li&gt;(NNP Community)<a name="line.64"></a>
<FONT color="green">065</FONT>             * &lt;li&gt;(: --)<a name="line.65"></a>
<FONT color="green">066</FONT>             * &lt;li&gt;(-NONE- *U*)<a name="line.66"></a>
<FONT color="green">067</FONT>             * &lt;/ul&gt;<a name="line.67"></a>
<FONT color="green">068</FONT>             */<a name="line.68"></a>
<FONT color="green">069</FONT>            public static final String LEAF_NODE_REGEX = "\\(([^( )]+) ([^( )]+)\\s*\\)";<a name="line.69"></a>
<FONT color="green">070</FONT>    <a name="line.70"></a>
<FONT color="green">071</FONT>            private static Pattern leafNodePattern = Pattern.compile(LEAF_NODE_REGEX);<a name="line.71"></a>
<FONT color="green">072</FONT>    <a name="line.72"></a>
<FONT color="green">073</FONT>            /**<a name="line.73"></a>
<FONT color="green">074</FONT>             * Uses the leafNodePattern to identify a string as a terminal. Examples:<a name="line.74"></a>
<FONT color="green">075</FONT>             * &lt;ul&gt;<a name="line.75"></a>
<FONT color="green">076</FONT>             * &lt;li&gt;parseFragment = "(NNP Community)", returns a leaf node<a name="line.76"></a>
<FONT color="green">077</FONT>             * &lt;li&gt;parseFragment = "(QP ($ $) (CD 107) (CD million) )", returns null<a name="line.77"></a>
<FONT color="green">078</FONT>             * &lt;/ul&gt;<a name="line.78"></a>
<FONT color="green">079</FONT>             * <a name="line.79"></a>
<FONT color="green">080</FONT>             * @param parseFragment<a name="line.80"></a>
<FONT color="green">081</FONT>             *            some fragment of a treebank parse.<a name="line.81"></a>
<FONT color="green">082</FONT>             * @return if the string matches, then a node will be returned. Otherwise,<a name="line.82"></a>
<FONT color="green">083</FONT>             *         null is returned.<a name="line.83"></a>
<FONT color="green">084</FONT>             */<a name="line.84"></a>
<FONT color="green">085</FONT>            protected static TreebankNode getLeafNode(String parseFragment) {<a name="line.85"></a>
<FONT color="green">086</FONT>                    Matcher leafNodeMatcher = leafNodePattern.matcher(parseFragment);<a name="line.86"></a>
<FONT color="green">087</FONT>                    if (leafNodeMatcher.matches()) {<a name="line.87"></a>
<FONT color="green">088</FONT>                            String type = leafNodeMatcher.group(1);<a name="line.88"></a>
<FONT color="green">089</FONT>                            String value = leafNodeMatcher.group(2);<a name="line.89"></a>
<FONT color="green">090</FONT>                            TreebankNode node = new TreebankNode();<a name="line.90"></a>
<FONT color="green">091</FONT>                            node.setType(getTypeFromType(type));<a name="line.91"></a>
<FONT color="green">092</FONT>                            node.setTags(getTagsFromType(type));<a name="line.92"></a>
<FONT color="green">093</FONT>                            node.setValue(value);<a name="line.93"></a>
<FONT color="green">094</FONT>                            node.setLeaf(true);<a name="line.94"></a>
<FONT color="green">095</FONT>                            // the token and the value will almost always be the same except for<a name="line.95"></a>
<FONT color="green">096</FONT>                            // a few special values (e.g. "-RCB-", "-LCB-", and "-NONE-")<a name="line.96"></a>
<FONT color="green">097</FONT>                            String token = getToken(node.getValue(), node.getType());<a name="line.97"></a>
<FONT color="green">098</FONT>                            node.setText(token);<a name="line.98"></a>
<FONT color="green">099</FONT>                            return node;<a name="line.99"></a>
<FONT color="green">100</FONT>                    }<a name="line.100"></a>
<FONT color="green">101</FONT>                    return null;<a name="line.101"></a>
<FONT color="green">102</FONT>            }<a name="line.102"></a>
<FONT color="green">103</FONT>    <a name="line.103"></a>
<FONT color="green">104</FONT>            private static String getTypeFromType(String fullType) {<a name="line.104"></a>
<FONT color="green">105</FONT>                    if (fullType.startsWith("-")) return fullType.substring(0, fullType.indexOf('-', 1) + 1);<a name="line.105"></a>
<FONT color="green">106</FONT>    <a name="line.106"></a>
<FONT color="green">107</FONT>                    return fullType.split("[-=]")[0];<a name="line.107"></a>
<FONT color="green">108</FONT>            }<a name="line.108"></a>
<FONT color="green">109</FONT>    <a name="line.109"></a>
<FONT color="green">110</FONT>            private static String[] getTagsFromType(String fullType) {<a name="line.110"></a>
<FONT color="green">111</FONT>                    if (fullType.startsWith("-")) {<a name="line.111"></a>
<FONT color="green">112</FONT>                            String rest = fullType.substring(fullType.indexOf('-', 1) + 1);<a name="line.112"></a>
<FONT color="green">113</FONT>                            if (rest.length() &gt; 0) return rest.split("[-=]");<a name="line.113"></a>
<FONT color="green">114</FONT>                            else return new String[0];<a name="line.114"></a>
<FONT color="green">115</FONT>                    }<a name="line.115"></a>
<FONT color="green">116</FONT>                    else {<a name="line.116"></a>
<FONT color="green">117</FONT>                            String[] parts = fullType.split("[-=]");<a name="line.117"></a>
<FONT color="green">118</FONT>                            String[] tags = new String[parts.length - 1];<a name="line.118"></a>
<FONT color="green">119</FONT>    <a name="line.119"></a>
<FONT color="green">120</FONT>                            for (int i = 1; i &lt; parts.length; i++)<a name="line.120"></a>
<FONT color="green">121</FONT>                                    tags[i - 1] = parts[i];<a name="line.121"></a>
<FONT color="green">122</FONT>                            return tags;<a name="line.122"></a>
<FONT color="green">123</FONT>                    }<a name="line.123"></a>
<FONT color="green">124</FONT>            }<a name="line.124"></a>
<FONT color="green">125</FONT>    <a name="line.125"></a>
<FONT color="green">126</FONT>            /**<a name="line.126"></a>
<FONT color="green">127</FONT>             * used to identify the type of a consituent in a treebank parse tree. It<a name="line.127"></a>
<FONT color="green">128</FONT>             * will match strings such as:<a name="line.128"></a>
<FONT color="green">129</FONT>             * &lt;ul&gt;<a name="line.129"></a>
<FONT color="green">130</FONT>             * &lt;li&gt;"NNP" in "(NNP Community)"<a name="line.130"></a>
<FONT color="green">131</FONT>             * &lt;li&gt;":" in "(: --)"<a name="line.131"></a>
<FONT color="green">132</FONT>             * &lt;li&gt;"-NONE-" in "(-NONE- *U*)"<a name="line.132"></a>
<FONT color="green">133</FONT>             * &lt;/ul&gt;<a name="line.133"></a>
<FONT color="green">134</FONT>             */<a name="line.134"></a>
<FONT color="green">135</FONT>            public static final String TYPE_REGEX = "^\\(([^() ]+)";<a name="line.135"></a>
<FONT color="green">136</FONT>    <a name="line.136"></a>
<FONT color="green">137</FONT>            private static Pattern typePattern = Pattern.compile(TYPE_REGEX);<a name="line.137"></a>
<FONT color="green">138</FONT>    <a name="line.138"></a>
<FONT color="green">139</FONT>            /**<a name="line.139"></a>
<FONT color="green">140</FONT>             * Returns the type of a constituent of some fragment of a treebank parse.<a name="line.140"></a>
<FONT color="green">141</FONT>             * Assumes that the first character is a parenthesis. Examples:<a name="line.141"></a>
<FONT color="green">142</FONT>             * &lt;ul&gt;<a name="line.142"></a>
<FONT color="green">143</FONT>             * &lt;li&gt;parseFragment = "(NP-LOC (NNP Calif.) )" return = "NP-LOC"<a name="line.143"></a>
<FONT color="green">144</FONT>             * &lt;li&gt;parseFragment = "(NP" return "NP"<a name="line.144"></a>
<FONT color="green">145</FONT>             * &lt;li&gt;parseFragment = "(-NONE- *U*) ) (PP (IN of)" return = "-NONE-"<a name="line.145"></a>
<FONT color="green">146</FONT>             * &lt;/ul&gt;<a name="line.146"></a>
<FONT color="green">147</FONT>             * <a name="line.147"></a>
<FONT color="green">148</FONT>             * @param parseFragment<a name="line.148"></a>
<FONT color="green">149</FONT>             *            some fragment of a treebank parse<a name="line.149"></a>
<FONT color="green">150</FONT>             * @return the type of the constituent.<a name="line.150"></a>
<FONT color="green">151</FONT>             */<a name="line.151"></a>
<FONT color="green">152</FONT>            protected static String getType(String parseFragment) {<a name="line.152"></a>
<FONT color="green">153</FONT>                    Matcher typeMatcher = typePattern.matcher(parseFragment);<a name="line.153"></a>
<FONT color="green">154</FONT>                    if (typeMatcher.find()) return typeMatcher.group(1);<a name="line.154"></a>
<FONT color="green">155</FONT>                    return null;<a name="line.155"></a>
<FONT color="green">156</FONT>            }<a name="line.156"></a>
<FONT color="green">157</FONT>    <a name="line.157"></a>
<FONT color="green">158</FONT>            public static final String cleanUPRegex1 = "\\s+";<a name="line.158"></a>
<FONT color="green">159</FONT>    <a name="line.159"></a>
<FONT color="green">160</FONT>            private static final Pattern cleanUpPattern1 = Pattern.compile(cleanUPRegex1, Pattern.MULTILINE);<a name="line.160"></a>
<FONT color="green">161</FONT>    <a name="line.161"></a>
<FONT color="green">162</FONT>            public static final String cleanUPRegex2 = "\\( \\(";<a name="line.162"></a>
<FONT color="green">163</FONT>    <a name="line.163"></a>
<FONT color="green">164</FONT>            private static final Pattern cleanUpPattern2 = Pattern.compile(cleanUPRegex2, Pattern.MULTILINE);<a name="line.164"></a>
<FONT color="green">165</FONT>    <a name="line.165"></a>
<FONT color="green">166</FONT>            public static final String cleanUPRegex3 = "\\) \\)";<a name="line.166"></a>
<FONT color="green">167</FONT>    <a name="line.167"></a>
<FONT color="green">168</FONT>            private static final Pattern cleanUpPattern3 = Pattern.compile(cleanUPRegex3, Pattern.MULTILINE);<a name="line.168"></a>
<FONT color="green">169</FONT>    <a name="line.169"></a>
<FONT color="green">170</FONT>            public static final String cleanUPRegex4 = "\\s*\\(\\s*\\(";<a name="line.170"></a>
<FONT color="green">171</FONT>    <a name="line.171"></a>
<FONT color="green">172</FONT>            private static final Pattern cleanUpPattern4 = Pattern.compile(cleanUPRegex4, Pattern.MULTILINE);<a name="line.172"></a>
<FONT color="green">173</FONT>    <a name="line.173"></a>
<FONT color="green">174</FONT>            /**<a name="line.174"></a>
<FONT color="green">175</FONT>             * This method was created simply as a way to clean up the parse string for<a name="line.175"></a>
<FONT color="green">176</FONT>             * a sentence in the treebank syntax. The most important thing that it does<a name="line.176"></a>
<FONT color="green">177</FONT>             * is add a type called TOP to the top node of the sentence. This simplifies<a name="line.177"></a>
<FONT color="green">178</FONT>             * parsing. The other string replacements just remove white space and such<a name="line.178"></a>
<FONT color="green">179</FONT>             * and are probably unnecessary. This was inspired by the OpenNLP solution<a name="line.179"></a>
<FONT color="green">180</FONT>             * which takes in one line at a time from a file that has been modified in<a name="line.180"></a>
<FONT color="green">181</FONT>             * this way.<a name="line.181"></a>
<FONT color="green">182</FONT>             * <a name="line.182"></a>
<FONT color="green">183</FONT>             * @param parse<a name="line.183"></a>
<FONT color="green">184</FONT>             *            a String in the treebank format<a name="line.184"></a>
<FONT color="green">185</FONT>             * @return a String in the treebank that has been cleaned up a bit.<a name="line.185"></a>
<FONT color="green">186</FONT>             */<a name="line.186"></a>
<FONT color="green">187</FONT>            public static String prepareString(String parse) {<a name="line.187"></a>
<FONT color="green">188</FONT>                    parse = cleanUpPattern1.matcher(parse).replaceAll(" ");<a name="line.188"></a>
<FONT color="green">189</FONT>                    parse = cleanUpPattern2.matcher(parse).replaceAll("((");<a name="line.189"></a>
<FONT color="green">190</FONT>                    parse = cleanUpPattern3.matcher(parse).replaceAll("))");<a name="line.190"></a>
<FONT color="green">191</FONT>                    parse = cleanUpPattern4.matcher(parse).replaceFirst("(TOP (");<a name="line.191"></a>
<FONT color="green">192</FONT>                    return parse.trim();<a name="line.192"></a>
<FONT color="green">193</FONT>            }<a name="line.193"></a>
<FONT color="green">194</FONT>    <a name="line.194"></a>
<FONT color="green">195</FONT>            /**<a name="line.195"></a>
<FONT color="green">196</FONT>             * A treebank parse does not preserve whitespace information. This method<a name="line.196"></a>
<FONT color="green">197</FONT>             * provides a simple mechanism for inferring the original plain text of a<a name="line.197"></a>
<FONT color="green">198</FONT>             * treebank parse. If you have access to the original plain text, then you<a name="line.198"></a>
<FONT color="green">199</FONT>             * can bypass use of this method by calling the appropriate parse method.<a name="line.199"></a>
<FONT color="green">200</FONT>             * <a name="line.200"></a>
<FONT color="green">201</FONT>             * @see #parse(String, String, int)<a name="line.201"></a>
<FONT color="green">202</FONT>             * <a name="line.202"></a>
<FONT color="green">203</FONT>             * @param treebankText<a name="line.203"></a>
<FONT color="green">204</FONT>             *            One or more parses in Treebank parenthesized format.<a name="line.204"></a>
<FONT color="green">205</FONT>             * @return a "best" guess of the original plain text given in the parse.<a name="line.205"></a>
<FONT color="green">206</FONT>             */<a name="line.206"></a>
<FONT color="green">207</FONT>            public static String inferPlainText(String treebankText) {<a name="line.207"></a>
<FONT color="green">208</FONT>                    StringBuilder sb = new StringBuilder();<a name="line.208"></a>
<FONT color="green">209</FONT>                    for (String parse : splitSentences(treebankText)) {<a name="line.209"></a>
<FONT color="green">210</FONT>                            Matcher matcher = leafNodePattern.matcher(parse);<a name="line.210"></a>
<FONT color="green">211</FONT>                            while (matcher.find()) {<a name="line.211"></a>
<FONT color="green">212</FONT>                                    TreebankNode node = getLeafNode(matcher.group());<a name="line.212"></a>
<FONT color="green">213</FONT>                                    if (node.getText() != null &amp;&amp; node.getText().length() &gt; 0) {<a name="line.213"></a>
<FONT color="green">214</FONT>                                            int lastIndex = sb.length() - 1;<a name="line.214"></a>
<FONT color="green">215</FONT>                                            if (lastIndex &gt; 0 &amp;&amp; !needsSpaceBefore(node.getText()) &amp;&amp; sb.charAt(lastIndex) == ' ') {<a name="line.215"></a>
<FONT color="green">216</FONT>                                                    sb.deleteCharAt(lastIndex);<a name="line.216"></a>
<FONT color="green">217</FONT>                                            }<a name="line.217"></a>
<FONT color="green">218</FONT>                                            sb.append(node.getText());<a name="line.218"></a>
<FONT color="green">219</FONT>                                            if (needsSpaceAfter(node.getText())) {<a name="line.219"></a>
<FONT color="green">220</FONT>                                                    sb.append(" ");<a name="line.220"></a>
<FONT color="green">221</FONT>                                            }<a name="line.221"></a>
<FONT color="green">222</FONT>                                    }<a name="line.222"></a>
<FONT color="green">223</FONT>                            }<a name="line.223"></a>
<FONT color="green">224</FONT>                            int lastIndex = sb.length() - 1;<a name="line.224"></a>
<FONT color="green">225</FONT>                            if (sb.charAt(lastIndex) == ' ') {<a name="line.225"></a>
<FONT color="green">226</FONT>                                    sb.deleteCharAt(lastIndex);<a name="line.226"></a>
<FONT color="green">227</FONT>                            }<a name="line.227"></a>
<FONT color="green">228</FONT>                            sb.append('\n');<a name="line.228"></a>
<FONT color="green">229</FONT>                    }<a name="line.229"></a>
<FONT color="green">230</FONT>                    return sb.toString().trim();<a name="line.230"></a>
<FONT color="green">231</FONT>            }<a name="line.231"></a>
<FONT color="green">232</FONT>    <a name="line.232"></a>
<FONT color="green">233</FONT>            private static boolean needsSpaceBefore(String tokenText) {<a name="line.233"></a>
<FONT color="green">234</FONT>                    String[] noSpaceTokens = new String[] { ".", ",", ":", ";", "?", "'s", "'t", "\"", "!" };<a name="line.234"></a>
<FONT color="green">235</FONT>                    for (String noSpaceToken : noSpaceTokens) {<a name="line.235"></a>
<FONT color="green">236</FONT>                            if (tokenText.equals(noSpaceToken)) {<a name="line.236"></a>
<FONT color="green">237</FONT>                                    return false;<a name="line.237"></a>
<FONT color="green">238</FONT>                            }<a name="line.238"></a>
<FONT color="green">239</FONT>                    }<a name="line.239"></a>
<FONT color="green">240</FONT>                    return true;<a name="line.240"></a>
<FONT color="green">241</FONT>            }<a name="line.241"></a>
<FONT color="green">242</FONT>    <a name="line.242"></a>
<FONT color="green">243</FONT>            private static boolean needsSpaceAfter(String tokenText) {<a name="line.243"></a>
<FONT color="green">244</FONT>                    String[] noSpaceTokens = new String[] { "\"" };<a name="line.244"></a>
<FONT color="green">245</FONT>                    for (String noSpaceToken : noSpaceTokens) {<a name="line.245"></a>
<FONT color="green">246</FONT>                            if (tokenText.equals(noSpaceToken)) {<a name="line.246"></a>
<FONT color="green">247</FONT>                                    return false;<a name="line.247"></a>
<FONT color="green">248</FONT>                            }<a name="line.248"></a>
<FONT color="green">249</FONT>                    }<a name="line.249"></a>
<FONT color="green">250</FONT>                    return true;<a name="line.250"></a>
<FONT color="green">251</FONT>            }<a name="line.251"></a>
<FONT color="green">252</FONT>    <a name="line.252"></a>
<FONT color="green">253</FONT>            /**<a name="line.253"></a>
<FONT color="green">254</FONT>             * Create TreebankNode objects corresponding to the given TreeBank format<a name="line.254"></a>
<FONT color="green">255</FONT>             * parse, e.g.:<a name="line.255"></a>
<FONT color="green">256</FONT>             * <a name="line.256"></a>
<FONT color="green">257</FONT>             * &lt;PRE&gt;<a name="line.257"></a>
<FONT color="green">258</FONT>             * ( (X (NP (NP (NML (NN Complex ) (NN trait )) (NN analysis )) (PP (IN of ) (NP (DT the ) (NN mouse ) (NN striatum )))) (: : ) (S (NP-SBJ (JJ independent ) (NNS QTLs )) (VP (VBP modulate ) (NP (NP (NN volume )) (CC and ) (NP (NN neuron ) (NN number)))))) )<a name="line.258"></a>
<FONT color="green">259</FONT>             * &lt;/PRE&gt;<a name="line.259"></a>
<FONT color="green">260</FONT>             * <a name="line.260"></a>
<FONT color="green">261</FONT>             * The text will be inferred automatically from the words in the parse.<a name="line.261"></a>
<FONT color="green">262</FONT>             * <a name="line.262"></a>
<FONT color="green">263</FONT>             * @param parse<a name="line.263"></a>
<FONT color="green">264</FONT>             *            A TreeBank formatted parse<a name="line.264"></a>
<FONT color="green">265</FONT>             * @return The TreebankNode root of the parse tree<a name="line.265"></a>
<FONT color="green">266</FONT>             * @see #inferPlainText(String)<a name="line.266"></a>
<FONT color="green">267</FONT>             * @see #parse(String, String, int)<a name="line.267"></a>
<FONT color="green">268</FONT>             */<a name="line.268"></a>
<FONT color="green">269</FONT>            public static TopTreebankNode parse(String parse) {<a name="line.269"></a>
<FONT color="green">270</FONT>                    parse = prepareString(parse);<a name="line.270"></a>
<FONT color="green">271</FONT>                    String plainText = inferPlainText(parse).trim();<a name="line.271"></a>
<FONT color="green">272</FONT>                    return parse(parse, plainText, 0);<a name="line.272"></a>
<FONT color="green">273</FONT>            }<a name="line.273"></a>
<FONT color="green">274</FONT>    <a name="line.274"></a>
<FONT color="green">275</FONT>            private static void checkText(TreebankNode node, String text) {<a name="line.275"></a>
<FONT color="green">276</FONT>                    String text1 = node.getText();<a name="line.276"></a>
<FONT color="green">277</FONT>                    int start = node.getTextBegin();<a name="line.277"></a>
<FONT color="green">278</FONT>                    int end = node.getTextEnd();<a name="line.278"></a>
<FONT color="green">279</FONT>                    String text2 = text.substring(start, end);<a name="line.279"></a>
<FONT color="green">280</FONT>                    if (!text1.equals(text2)) {<a name="line.280"></a>
<FONT color="green">281</FONT>                            // TreeBank adds in (. .) nodes in odd places, e.g. when a sentence<a name="line.281"></a>
<FONT color="green">282</FONT>                            // ends with U.S. (and no final period). As a result, we need to<a name="line.282"></a>
<FONT color="green">283</FONT>                            // allow periods to match whitespace and adjust the node bounds.<a name="line.283"></a>
<FONT color="green">284</FONT>                            String prefix1 = text1.substring(0, text1.length() - 1);<a name="line.284"></a>
<FONT color="green">285</FONT>                            String prefix2 = text2.substring(0, text2.length() - 1);<a name="line.285"></a>
<FONT color="green">286</FONT>                            if (text1.endsWith(".") &amp;&amp; prefix1.equals(prefix2)) {<a name="line.286"></a>
<FONT color="green">287</FONT>                                    node.setTextEnd(node.getTextEnd() - 1);<a name="line.287"></a>
<FONT color="green">288</FONT>                            }<a name="line.288"></a>
<FONT color="green">289</FONT>                            else {<a name="line.289"></a>
<FONT color="green">290</FONT>                                    throw new IllegalArgumentException(<a name="line.290"></a>
<FONT color="green">291</FONT>                                                    "plain text does not align with tokens in treebank parse.  node text = '" + text1<a name="line.291"></a>
<FONT color="green">292</FONT>                                                                    + "'  plain text = '" + text2 + "'");<a name="line.292"></a>
<FONT color="green">293</FONT>                            }<a name="line.293"></a>
<FONT color="green">294</FONT>                    }<a name="line.294"></a>
<FONT color="green">295</FONT>            }<a name="line.295"></a>
<FONT color="green">296</FONT>    <a name="line.296"></a>
<FONT color="green">297</FONT>            /**<a name="line.297"></a>
<FONT color="green">298</FONT>             * Create TreebankNode objects corresponding to the given TreeBank format<a name="line.298"></a>
<FONT color="green">299</FONT>             * parse, e.g.:<a name="line.299"></a>
<FONT color="green">300</FONT>             * <a name="line.300"></a>
<FONT color="green">301</FONT>             * &lt;PRE&gt;<a name="line.301"></a>
<FONT color="green">302</FONT>             * ( (X (NP (NP (NML (NN Complex ) (NN trait )) (NN analysis )) (PP (IN of ) (NP (DT the ) (NN mouse ) (NN striatum )))) (: : ) (S (NP-SBJ (JJ independent ) (NNS QTLs )) (VP (VBP modulate ) (NP (NP (NN volume )) (CC and ) (NP (NN neuron ) (NN number)))))) )<a name="line.302"></a>
<FONT color="green">303</FONT>             * &lt;/PRE&gt;<a name="line.303"></a>
<FONT color="green">304</FONT>             * <a name="line.304"></a>
<FONT color="green">305</FONT>             * The start and end offsets of each TreebankNode will be aligned to the<a name="line.305"></a>
<FONT color="green">306</FONT>             * word offsets in the given text.<a name="line.306"></a>
<FONT color="green">307</FONT>             * <a name="line.307"></a>
<FONT color="green">308</FONT>             * @param parse<a name="line.308"></a>
<FONT color="green">309</FONT>             *            A TreeBank formatted parse<a name="line.309"></a>
<FONT color="green">310</FONT>             * @param text<a name="line.310"></a>
<FONT color="green">311</FONT>             *            The text to which the parse should be aligned<a name="line.311"></a>
<FONT color="green">312</FONT>             * @param textOffset<a name="line.312"></a>
<FONT color="green">313</FONT>             *            The character offset at which the parse text should start to<a name="line.313"></a>
<FONT color="green">314</FONT>             *            be aligned. For example, if the words of the parse start right<a name="line.314"></a>
<FONT color="green">315</FONT>             *            at the beginning of the text, the appropriate textOffset is 0.<a name="line.315"></a>
<FONT color="green">316</FONT>             * @return The TreebankNode root of the parse tree. The root node will be a<a name="line.316"></a>
<FONT color="green">317</FONT>             *         TopTreebankNode, and all its descendants will be TreebankNodes.<a name="line.317"></a>
<FONT color="green">318</FONT>             * @see TopTreebankNode<a name="line.318"></a>
<FONT color="green">319</FONT>             * @see TreebankNode<a name="line.319"></a>
<FONT color="green">320</FONT>             */<a name="line.320"></a>
<FONT color="green">321</FONT>            public static TopTreebankNode parse(String parse, String text, int textOffset) {<a name="line.321"></a>
<FONT color="green">322</FONT>                    try {<a name="line.322"></a>
<FONT color="green">323</FONT>                            TopTreebankNode topNode = new TopTreebankNode();<a name="line.323"></a>
<FONT color="green">324</FONT>                            parse = prepareString(parse);<a name="line.324"></a>
<FONT color="green">325</FONT>                            // used to capture the plain text of the sentence.<a name="line.325"></a>
<FONT color="green">326</FONT>                            StringBuffer consumedText = new StringBuffer();<a name="line.326"></a>
<FONT color="green">327</FONT>                            if (text != null) {<a name="line.327"></a>
<FONT color="green">328</FONT>                                    textOffset = movePastWhiteSpaceChars(text, textOffset);<a name="line.328"></a>
<FONT color="green">329</FONT>                                    consumedText.append(text.substring(0, textOffset));<a name="line.329"></a>
<FONT color="green">330</FONT>                            }<a name="line.330"></a>
<FONT color="green">331</FONT>            <a name="line.331"></a>
<FONT color="green">332</FONT>                            Stack&lt;Integer&gt; parseOffsetStack = new Stack&lt;Integer&gt;();<a name="line.332"></a>
<FONT color="green">333</FONT>                            Stack&lt;Integer&gt; plainTextOffsetStack = new Stack&lt;Integer&gt;();<a name="line.333"></a>
<FONT color="green">334</FONT>            <a name="line.334"></a>
<FONT color="green">335</FONT>                            // keeps the nodes that are waiting for their parents to be completed.<a name="line.335"></a>
<FONT color="green">336</FONT>                            Stack&lt;TreebankNode&gt; parseStack = new Stack&lt;TreebankNode&gt;();<a name="line.336"></a>
<FONT color="green">337</FONT>            <a name="line.337"></a>
<FONT color="green">338</FONT>                            for (int ci = 0; ci &lt; parse.length(); ci++) {<a name="line.338"></a>
<FONT color="green">339</FONT>                                    char c = parse.charAt(ci);<a name="line.339"></a>
<FONT color="green">340</FONT>                                    if (c == '(') {<a name="line.340"></a>
<FONT color="green">341</FONT>                                            // at the start of each constituent we will push the starting<a name="line.341"></a>
<FONT color="green">342</FONT>                                            // index of it<a name="line.342"></a>
<FONT color="green">343</FONT>                                            // w.r.t. the parse string.<a name="line.343"></a>
<FONT color="green">344</FONT>                                            parseOffsetStack.push(ci);<a name="line.344"></a>
<FONT color="green">345</FONT>                                            // also push the starting index w.r.t. the plain text of the<a name="line.345"></a>
<FONT color="green">346</FONT>                                            // sentence.<a name="line.346"></a>
<FONT color="green">347</FONT>                                            plainTextOffsetStack.push(consumedText.length());<a name="line.347"></a>
<FONT color="green">348</FONT>                                    }<a name="line.348"></a>
<FONT color="green">349</FONT>                                    else if (c == ')') {<a name="line.349"></a>
<FONT color="green">350</FONT>                                            int begin = parseOffsetStack.pop();<a name="line.350"></a>
<FONT color="green">351</FONT>                                            int end = ci;<a name="line.351"></a>
<FONT color="green">352</FONT>                                            // the portion of the parse string that corresponds to the<a name="line.352"></a>
<FONT color="green">353</FONT>                                            // constituent that<a name="line.353"></a>
<FONT color="green">354</FONT>                                            // we found the left bracket for ')'.<a name="line.354"></a>
<FONT color="green">355</FONT>                                            String subParse = parse.substring(begin, end + 1);<a name="line.355"></a>
<FONT color="green">356</FONT>            <a name="line.356"></a>
<FONT color="green">357</FONT>                                            int textBegin = plainTextOffsetStack.pop();<a name="line.357"></a>
<FONT color="green">358</FONT>            <a name="line.358"></a>
<FONT color="green">359</FONT>                                            TreebankNode node = getLeafNode(subParse);<a name="line.359"></a>
<FONT color="green">360</FONT>                                            if (node != null) {<a name="line.360"></a>
<FONT color="green">361</FONT>                                                    node.setTopNode(topNode);<a name="line.361"></a>
<FONT color="green">362</FONT>                                                    node.setParseBegin(begin);<a name="line.362"></a>
<FONT color="green">363</FONT>                                                    node.setParseEnd(end + 1);<a name="line.363"></a>
<FONT color="green">364</FONT>                                                    String token = node.getText();<a name="line.364"></a>
<FONT color="green">365</FONT>            <a name="line.365"></a>
<FONT color="green">366</FONT>                                                    if (token.length() &gt; 0) {<a name="line.366"></a>
<FONT color="green">367</FONT>                                                            int realBegin = movePastWhiteSpaceChars(text, textBegin);<a name="line.367"></a>
<FONT color="green">368</FONT>                                                            consumedText.append(text.substring(textBegin, realBegin));<a name="line.368"></a>
<FONT color="green">369</FONT>                                                            consumedText.append(token);<a name="line.369"></a>
<FONT color="green">370</FONT>                                                            node.setTextBegin(realBegin);<a name="line.370"></a>
<FONT color="green">371</FONT>                                                            node.setTextEnd(realBegin + token.length());<a name="line.371"></a>
<FONT color="green">372</FONT>            <a name="line.372"></a>
<FONT color="green">373</FONT>                                                    }<a name="line.373"></a>
<FONT color="green">374</FONT>                                                    else {<a name="line.374"></a>
<FONT color="green">375</FONT>                                                            node.setTextBegin(textBegin);<a name="line.375"></a>
<FONT color="green">376</FONT>                                                            node.setTextEnd(textBegin + token.length());<a name="line.376"></a>
<FONT color="green">377</FONT>                                                    }<a name="line.377"></a>
<FONT color="green">378</FONT>                                                    checkText(node, text);<a name="line.378"></a>
<FONT color="green">379</FONT>                                                    parseStack.push(node);<a name="line.379"></a>
<FONT color="green">380</FONT>                                            }<a name="line.380"></a>
<FONT color="green">381</FONT>                                            else {<a name="line.381"></a>
<FONT color="green">382</FONT>                                                    if (parse.lastIndexOf(')') == ci) // the last ')' is the top<a name="line.382"></a>
<FONT color="green">383</FONT>                                                    // node.<a name="line.383"></a>
<FONT color="green">384</FONT>                                                    node = topNode; // this is the instance that will be<a name="line.384"></a>
<FONT color="green">385</FONT>                                                    // returned.<a name="line.385"></a>
<FONT color="green">386</FONT>                                                    else node = new TreebankNode();<a name="line.386"></a>
<FONT color="green">387</FONT>                                                    node.setTopNode(topNode);<a name="line.387"></a>
<FONT color="green">388</FONT>                                                    node.setParseBegin(begin);<a name="line.388"></a>
<FONT color="green">389</FONT>                                                    node.setParseEnd(end + 1);<a name="line.389"></a>
<FONT color="green">390</FONT>                                                    String type = getType(subParse);<a name="line.390"></a>
<FONT color="green">391</FONT>                                                    node.setType(getTypeFromType(type));<a name="line.391"></a>
<FONT color="green">392</FONT>                                                    node.setTags(getTagsFromType(type));<a name="line.392"></a>
<FONT color="green">393</FONT>                                                    node.setLeaf(false);<a name="line.393"></a>
<FONT color="green">394</FONT>                                                    // keep adding the nodes on the stack until it is empty or<a name="line.394"></a>
<FONT color="green">395</FONT>                                                    // the next node on the stack starts before the current node<a name="line.395"></a>
<FONT color="green">396</FONT>                                                    // (i.e. has a different<a name="line.396"></a>
<FONT color="green">397</FONT>                                                    // parent than the current node that will be completed<a name="line.397"></a>
<FONT color="green">398</FONT>                                                    // later.)<a name="line.398"></a>
<FONT color="green">399</FONT>                                                    while (parseStack.size() &gt; 0 &amp;&amp; parseStack.peek().getParseBegin() &gt; node.getParseBegin()) {<a name="line.399"></a>
<FONT color="green">400</FONT>                                                            TreebankNode child = parseStack.pop();<a name="line.400"></a>
<FONT color="green">401</FONT>                                                            node.addChild(child);<a name="line.401"></a>
<FONT color="green">402</FONT>                                                            child.setParent(node);<a name="line.402"></a>
<FONT color="green">403</FONT>                                                    }<a name="line.403"></a>
<FONT color="green">404</FONT>                                                    // we typically add a token followed by a space to<a name="line.404"></a>
<FONT color="green">405</FONT>                                                    // plainText, except when the<a name="line.405"></a>
<FONT color="green">406</FONT>                                                    // token is an empty string as it is when the corresponding<a name="line.406"></a>
<FONT color="green">407</FONT>                                                    // type is -NONE-<a name="line.407"></a>
<FONT color="green">408</FONT>                                                    int realBegin = movePastWhiteSpaceChars(text, textBegin);<a name="line.408"></a>
<FONT color="green">409</FONT>                                                    node.setTextBegin(realBegin);<a name="line.409"></a>
<FONT color="green">410</FONT>                                                    node.setTextEnd(Math.max(realBegin, consumedText.length()));<a name="line.410"></a>
<FONT color="green">411</FONT>            <a name="line.411"></a>
<FONT color="green">412</FONT>                                                    try {<a name="line.412"></a>
<FONT color="green">413</FONT>                                                            node.setText(consumedText.substring(node.getTextBegin(), node.getTextEnd()));<a name="line.413"></a>
<FONT color="green">414</FONT>                                                    }<a name="line.414"></a>
<FONT color="green">415</FONT>                                                    catch (StringIndexOutOfBoundsException sioobe) {<a name="line.415"></a>
<FONT color="green">416</FONT>                                                            node.setText("");<a name="line.416"></a>
<FONT color="green">417</FONT>                                                    }<a name="line.417"></a>
<FONT color="green">418</FONT>                                                    checkText(node, text);<a name="line.418"></a>
<FONT color="green">419</FONT>                                                    parseStack.push(node);<a name="line.419"></a>
<FONT color="green">420</FONT>                                            }<a name="line.420"></a>
<FONT color="green">421</FONT>                                    }<a name="line.421"></a>
<FONT color="green">422</FONT>                            }<a name="line.422"></a>
<FONT color="green">423</FONT>            <a name="line.423"></a>
<FONT color="green">424</FONT>                            topNode.setTreebankParse(parse);<a name="line.424"></a>
<FONT color="green">425</FONT>                            topNode.initTerminalNodes();<a name="line.425"></a>
<FONT color="green">426</FONT>                            return topNode;<a name="line.426"></a>
<FONT color="green">427</FONT>                    } catch (RuntimeException e) {<a name="line.427"></a>
<FONT color="green">428</FONT>                            throw new IllegalArgumentException("exception thrown when parsing the following: "+parse, e);<a name="line.428"></a>
<FONT color="green">429</FONT>                    }<a name="line.429"></a>
<FONT color="green">430</FONT>            }<a name="line.430"></a>
<FONT color="green">431</FONT>    <a name="line.431"></a>
<FONT color="green">432</FONT>            private static final Pattern nonwhiteSpaceCharPattern = Pattern.compile("[^\\s]");<a name="line.432"></a>
<FONT color="green">433</FONT>    <a name="line.433"></a>
<FONT color="green">434</FONT>            public static int movePastWhiteSpaceChars(String text, int textOffset) {<a name="line.434"></a>
<FONT color="green">435</FONT>                    Matcher matcher = nonwhiteSpaceCharPattern.matcher(text);<a name="line.435"></a>
<FONT color="green">436</FONT>                    if (matcher.find(textOffset)) {<a name="line.436"></a>
<FONT color="green">437</FONT>                            return matcher.start();<a name="line.437"></a>
<FONT color="green">438</FONT>                    }<a name="line.438"></a>
<FONT color="green">439</FONT>                    return textOffset;<a name="line.439"></a>
<FONT color="green">440</FONT>            }<a name="line.440"></a>
<FONT color="green">441</FONT>    <a name="line.441"></a>
<FONT color="green">442</FONT>            /**<a name="line.442"></a>
<FONT color="green">443</FONT>             * Replace specially encoded tokens with their original textual<a name="line.443"></a>
<FONT color="green">444</FONT>             * representation. (http://www.cis.upenn.edu/~treebank/tokenization.html)<a name="line.444"></a>
<FONT color="green">445</FONT>             * <a name="line.445"></a>
<FONT color="green">446</FONT>             * @param value<a name="line.446"></a>
<FONT color="green">447</FONT>             * @param type<a name="line.447"></a>
<FONT color="green">448</FONT>             * @return The string in its original textual representation.<a name="line.448"></a>
<FONT color="green">449</FONT>             */<a name="line.449"></a>
<FONT color="green">450</FONT>            private static String getToken(String value, String type) {<a name="line.450"></a>
<FONT color="green">451</FONT>                    value = value.replace("-RCB-", "}");<a name="line.451"></a>
<FONT color="green">452</FONT>                    value = value.replace("-LCB-", "{");<a name="line.452"></a>
<FONT color="green">453</FONT>                    value = value.replace("-RRB-", ")");<a name="line.453"></a>
<FONT color="green">454</FONT>                    value = value.replace("-LRB-", "(");<a name="line.454"></a>
<FONT color="green">455</FONT>                    value = value.replace("-RSB-", "]");<a name="line.455"></a>
<FONT color="green">456</FONT>                    value = value.replace("-LSB-", "[");<a name="line.456"></a>
<FONT color="green">457</FONT>                    value = value.replace("``", "\"");<a name="line.457"></a>
<FONT color="green">458</FONT>                    value = value.replace("''", "\"");<a name="line.458"></a>
<FONT color="green">459</FONT>                    <a name="line.459"></a>
<FONT color="green">460</FONT>                    if (type.equals("-NONE-")) return "";<a name="line.460"></a>
<FONT color="green">461</FONT>    <a name="line.461"></a>
<FONT color="green">462</FONT>                    if (value.contains("\\/")) return value.replace("\\/", "/");<a name="line.462"></a>
<FONT color="green">463</FONT>    <a name="line.463"></a>
<FONT color="green">464</FONT>                    if (type.startsWith("")) {<a name="line.464"></a>
<FONT color="green">465</FONT>                            value = value.substring(1);<a name="line.465"></a>
<FONT color="green">466</FONT>                    }<a name="line.466"></a>
<FONT color="green">467</FONT>    <a name="line.467"></a>
<FONT color="green">468</FONT>                    return value;<a name="line.468"></a>
<FONT color="green">469</FONT>            }<a name="line.469"></a>
<FONT color="green">470</FONT>    <a name="line.470"></a>
<FONT color="green">471</FONT>            /**<a name="line.471"></a>
<FONT color="green">472</FONT>             * Generally speaking, we expect one treebanked sentence per line.  This method will <a name="line.472"></a>
<FONT color="green">473</FONT>             * simply return the lines of a document assuming that each line has matching parentheses.  However,<a name="line.473"></a>
<FONT color="green">474</FONT>             * the native penn treebank data contains parsed sentences that are broken up across multiple lines.<a name="line.474"></a>
<FONT color="green">475</FONT>             * Each sentence in the PTB starts with "( (S..." and so we split on this to get the sentences.<a name="line.475"></a>
<FONT color="green">476</FONT>             * If this method sees "( (S...", then it will return the contents split on that pattern.  If not,<a name="line.476"></a>
<FONT color="green">477</FONT>             * it will return the lines of the input string.    <a name="line.477"></a>
<FONT color="green">478</FONT>             * <a name="line.478"></a>
<FONT color="green">479</FONT>             * Splits an .mrg file (e.g. wsj/mrg/00/wsj_0020.mrg) into sentence parses.<a name="line.479"></a>
<FONT color="green">480</FONT>             * <a name="line.480"></a>
<FONT color="green">481</FONT>             * @param mrgContents<a name="line.481"></a>
<FONT color="green">482</FONT>             * @return individual sentence parses from treebank - i.e. strings of the<a name="line.482"></a>
<FONT color="green">483</FONT>             *         form "( (S..."<a name="line.483"></a>
<FONT color="green">484</FONT>             */<a name="line.484"></a>
<FONT color="green">485</FONT>    <a name="line.485"></a>
<FONT color="green">486</FONT>            public static String[] splitSentences(String mrgContents) {<a name="line.486"></a>
<FONT color="green">487</FONT>                    // Splitting on this regular expression can cause the first value<a name="line.487"></a>
<FONT color="green">488</FONT>                    // in the array to be an empty string if e.g. the first line of the file<a name="line.488"></a>
<FONT color="green">489</FONT>                    // is blank<a name="line.489"></a>
<FONT color="green">490</FONT>                    String[] contents = mrgContents.split("(?=\\(\\s*\\()");<a name="line.490"></a>
<FONT color="green">491</FONT>                    if (contents.length &gt; 1) {<a name="line.491"></a>
<FONT color="green">492</FONT>                            if (contents.length &gt; 0 &amp;&amp; contents[0].trim().equals("")) {<a name="line.492"></a>
<FONT color="green">493</FONT>                                    String[] returnValues = new String[contents.length - 1];<a name="line.493"></a>
<FONT color="green">494</FONT>                                    System.arraycopy(contents, 1, returnValues, 0, returnValues.length);<a name="line.494"></a>
<FONT color="green">495</FONT>                                    return returnValues;<a name="line.495"></a>
<FONT color="green">496</FONT>                            }<a name="line.496"></a>
<FONT color="green">497</FONT>                            else {<a name="line.497"></a>
<FONT color="green">498</FONT>                                    String[] returnValues = new String[contents.length];<a name="line.498"></a>
<FONT color="green">499</FONT>                                    System.arraycopy(contents, 0, returnValues, 0, returnValues.length);<a name="line.499"></a>
<FONT color="green">500</FONT>                                    return returnValues;<a name="line.500"></a>
<FONT color="green">501</FONT>                            }<a name="line.501"></a>
<FONT color="green">502</FONT>                    }<a name="line.502"></a>
<FONT color="green">503</FONT>    <a name="line.503"></a>
<FONT color="green">504</FONT>                    String[] lines = mrgContents.split("\r?\n");<a name="line.504"></a>
<FONT color="green">505</FONT>                    for (String line : lines) {<a name="line.505"></a>
<FONT color="green">506</FONT>                            if (!parensMatch(line)) {<a name="line.506"></a>
<FONT color="green">507</FONT>                                    throw new IllegalArgumentException("Parentheses counts do not match for treebank sentence: " + line);<a name="line.507"></a>
<FONT color="green">508</FONT>                            }<a name="line.508"></a>
<FONT color="green">509</FONT>                    }<a name="line.509"></a>
<FONT color="green">510</FONT>                    return lines;<a name="line.510"></a>
<FONT color="green">511</FONT>            }<a name="line.511"></a>
<FONT color="green">512</FONT>    <a name="line.512"></a>
<FONT color="green">513</FONT>            public static boolean parensMatch(String contents) {<a name="line.513"></a>
<FONT color="green">514</FONT>                    int leftParenCount = 0;<a name="line.514"></a>
<FONT color="green">515</FONT>                    int rightParenCount = 0;<a name="line.515"></a>
<FONT color="green">516</FONT>    <a name="line.516"></a>
<FONT color="green">517</FONT>                    for (char c : contents.toCharArray()) {<a name="line.517"></a>
<FONT color="green">518</FONT>                            if (c == '(') leftParenCount++;<a name="line.518"></a>
<FONT color="green">519</FONT>                            if (c == ')') rightParenCount++;<a name="line.519"></a>
<FONT color="green">520</FONT>                    }<a name="line.520"></a>
<FONT color="green">521</FONT>    <a name="line.521"></a>
<FONT color="green">522</FONT>                    return leftParenCount == rightParenCount;<a name="line.522"></a>
<FONT color="green">523</FONT>    <a name="line.523"></a>
<FONT color="green">524</FONT>            }<a name="line.524"></a>
<FONT color="green">525</FONT>    <a name="line.525"></a>
<FONT color="green">526</FONT>            /**<a name="line.526"></a>
<FONT color="green">527</FONT>             * This method parses an entire documents worth of treebanked sentences.<a name="line.527"></a>
<FONT color="green">528</FONT>             * <a name="line.528"></a>
<FONT color="green">529</FONT>             * @param parse<a name="line.529"></a>
<FONT color="green">530</FONT>             * @param textOffset<a name="line.530"></a>
<FONT color="green">531</FONT>             *            a value that corresponds to the character offset of the first<a name="line.531"></a>
<FONT color="green">532</FONT>             *            character of the document. The appropriate value for this<a name="line.532"></a>
<FONT color="green">533</FONT>             *            method will typically be 0.<a name="line.533"></a>
<FONT color="green">534</FONT>             * @param text<a name="line.534"></a>
<FONT color="green">535</FONT>             *            a single document provided as plain text. If you do not have<a name="line.535"></a>
<FONT color="green">536</FONT>             *            access to the original plain text of the document, you can<a name="line.536"></a>
<FONT color="green">537</FONT>             *            generate some using {@link #inferPlainText(String)}.<a name="line.537"></a>
<FONT color="green">538</FONT>             */<a name="line.538"></a>
<FONT color="green">539</FONT>            public static List&lt;TopTreebankNode&gt; parseDocument(String parse, int textOffset, String text) {<a name="line.539"></a>
<FONT color="green">540</FONT>                    List&lt;TopTreebankNode&gt; returnValues = new ArrayList&lt;TopTreebankNode&gt;();<a name="line.540"></a>
<FONT color="green">541</FONT>                    String[] sentenceParses = splitSentences(parse);<a name="line.541"></a>
<FONT color="green">542</FONT>    <a name="line.542"></a>
<FONT color="green">543</FONT>                    for (String sentenceParse : sentenceParses) {<a name="line.543"></a>
<FONT color="green">544</FONT>                            TopTreebankNode topNode = parse(sentenceParse, text, textOffset);<a name="line.544"></a>
<FONT color="green">545</FONT>                            textOffset = topNode.getTextEnd();<a name="line.545"></a>
<FONT color="green">546</FONT>                            returnValues.add(topNode);<a name="line.546"></a>
<FONT color="green">547</FONT>                    }<a name="line.547"></a>
<FONT color="green">548</FONT>                    return returnValues;<a name="line.548"></a>
<FONT color="green">549</FONT>            }<a name="line.549"></a>
<FONT color="green">550</FONT>    <a name="line.550"></a>
<FONT color="green">551</FONT>    }<a name="line.551"></a>




























































</PRE>
</BODY>
</HTML>
