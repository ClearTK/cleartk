<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
<title>Source code</title>
<link rel="stylesheet" type="text/css" href="../../../../../../stylesheet.css" title="Style">
</head>
<body>
<div class="sourceContainer">
<pre><span class="sourceLineNo">001</span>/** <a name="line.1"></a>
<span class="sourceLineNo">002</span> * Copyright (c) 2007-2008, Regents of the University of Colorado <a name="line.2"></a>
<span class="sourceLineNo">003</span> * All rights reserved.<a name="line.3"></a>
<span class="sourceLineNo">004</span> * <a name="line.4"></a>
<span class="sourceLineNo">005</span> * Redistribution and use in source and binary forms, with or without<a name="line.5"></a>
<span class="sourceLineNo">006</span> * modification, are permitted provided that the following conditions are met:<a name="line.6"></a>
<span class="sourceLineNo">007</span> * <a name="line.7"></a>
<span class="sourceLineNo">008</span> * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. <a name="line.8"></a>
<span class="sourceLineNo">009</span> * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. <a name="line.9"></a>
<span class="sourceLineNo">010</span> * Neither the name of the University of Colorado at Boulder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. <a name="line.10"></a>
<span class="sourceLineNo">011</span> * <a name="line.11"></a>
<span class="sourceLineNo">012</span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"<a name="line.12"></a>
<span class="sourceLineNo">013</span> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE<a name="line.13"></a>
<span class="sourceLineNo">014</span> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<a name="line.14"></a>
<span class="sourceLineNo">015</span> * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE<a name="line.15"></a>
<span class="sourceLineNo">016</span> * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR<a name="line.16"></a>
<span class="sourceLineNo">017</span> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF<a name="line.17"></a>
<span class="sourceLineNo">018</span> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS<a name="line.18"></a>
<span class="sourceLineNo">019</span> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN<a name="line.19"></a>
<span class="sourceLineNo">020</span> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)<a name="line.20"></a>
<span class="sourceLineNo">021</span> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE<a name="line.21"></a>
<span class="sourceLineNo">022</span> * POSSIBILITY OF SUCH DAMAGE. <a name="line.22"></a>
<span class="sourceLineNo">023</span> */<a name="line.23"></a>
<span class="sourceLineNo">024</span>package org.cleartk.syntax.constituent.util;<a name="line.24"></a>
<span class="sourceLineNo">025</span><a name="line.25"></a>
<span class="sourceLineNo">026</span>import java.util.ArrayList;<a name="line.26"></a>
<span class="sourceLineNo">027</span>import java.util.List;<a name="line.27"></a>
<span class="sourceLineNo">028</span>import java.util.Stack;<a name="line.28"></a>
<span class="sourceLineNo">029</span>import java.util.regex.Matcher;<a name="line.29"></a>
<span class="sourceLineNo">030</span>import java.util.regex.Pattern;<a name="line.30"></a>
<span class="sourceLineNo">031</span><a name="line.31"></a>
<span class="sourceLineNo">032</span>/**<a name="line.32"></a>
<span class="sourceLineNo">033</span> * This class was written to be a stand alone parser for the Penn Treebank data. Basically, I need a<a name="line.33"></a>
<span class="sourceLineNo">034</span> * way to synch up the propbank data with extents of plain text that are labeled. This is not<a name="line.34"></a>
<span class="sourceLineNo">035</span> * possible to do without parsing the treebank data first. The parse method will parse a single<a name="line.35"></a>
<span class="sourceLineNo">036</span> * sentence from the treebank data from e.g. wsj/mrg/06/wsj_0656.mrg.<a name="line.36"></a>
<span class="sourceLineNo">037</span> * <a name="line.37"></a>
<span class="sourceLineNo">038</span> * I initially looked at the OpenNLP treebank parser but they made a few assumptions about they<a name="line.38"></a>
<span class="sourceLineNo">039</span> * wanted to keep for the parser that would make it difficult to align with the propbank data. See:<a name="line.39"></a>
<span class="sourceLineNo">040</span> * http://sourceforge.net/projects/opennlp/forums/forum/9943/topic/1751983 for relevant discussion.<a name="line.40"></a>
<span class="sourceLineNo">041</span> * I looked at their parsing implementation and tried to modify it. However, I think the code below<a name="line.41"></a>
<span class="sourceLineNo">042</span> * bears little resemblance to theirs. But there may yet be some snippets taken directly out of that<a name="line.42"></a>
<span class="sourceLineNo">043</span> * code. The two regular expressions used are very similar.<a name="line.43"></a>
<span class="sourceLineNo">044</span> * <a name="line.44"></a>
<span class="sourceLineNo">045</span> * &lt;br&gt;<a name="line.45"></a>
<span class="sourceLineNo">046</span> * Copyright (c) 2007-2008, Regents of the University of Colorado &lt;br&gt;<a name="line.46"></a>
<span class="sourceLineNo">047</span> * All rights reserved.<a name="line.47"></a>
<span class="sourceLineNo">048</span> * <a name="line.48"></a>
<span class="sourceLineNo">049</span> * <a name="line.49"></a>
<span class="sourceLineNo">050</span> * @author Philip Ogren<a name="line.50"></a>
<span class="sourceLineNo">051</span> */<a name="line.51"></a>
<span class="sourceLineNo">052</span>public class TreebankFormatParser {<a name="line.52"></a>
<span class="sourceLineNo">053</span>  /**<a name="line.53"></a>
<span class="sourceLineNo">054</span>   * used to identify tokens in Penn Treebank labeled constituents. It will match strings such as:<a name="line.54"></a>
<span class="sourceLineNo">055</span>   * &lt;ul&gt;<a name="line.55"></a>
<span class="sourceLineNo">056</span>   * &lt;li&gt;(NNP Community)<a name="line.56"></a>
<span class="sourceLineNo">057</span>   * &lt;li&gt;(: --)<a name="line.57"></a>
<span class="sourceLineNo">058</span>   * &lt;li&gt;(-NONE- *U*)<a name="line.58"></a>
<span class="sourceLineNo">059</span>   * &lt;/ul&gt;<a name="line.59"></a>
<span class="sourceLineNo">060</span>   */<a name="line.60"></a>
<span class="sourceLineNo">061</span>  public static final String LEAF_NODE_REGEX = "\\(([^( )]+) ([^( )]+)\\s*\\)";<a name="line.61"></a>
<span class="sourceLineNo">062</span><a name="line.62"></a>
<span class="sourceLineNo">063</span>  private static Pattern leafNodePattern = Pattern.compile(LEAF_NODE_REGEX);<a name="line.63"></a>
<span class="sourceLineNo">064</span><a name="line.64"></a>
<span class="sourceLineNo">065</span>  /**<a name="line.65"></a>
<span class="sourceLineNo">066</span>   * Uses the leafNodePattern to identify a string as a terminal. Examples:<a name="line.66"></a>
<span class="sourceLineNo">067</span>   * &lt;ul&gt;<a name="line.67"></a>
<span class="sourceLineNo">068</span>   * &lt;li&gt;parseFragment = "(NNP Community)", returns a leaf node<a name="line.68"></a>
<span class="sourceLineNo">069</span>   * &lt;li&gt;parseFragment = "(QP ($ $) (CD 107) (CD million) )", returns null<a name="line.69"></a>
<span class="sourceLineNo">070</span>   * &lt;/ul&gt;<a name="line.70"></a>
<span class="sourceLineNo">071</span>   * <a name="line.71"></a>
<span class="sourceLineNo">072</span>   * @param parseFragment<a name="line.72"></a>
<span class="sourceLineNo">073</span>   *          some fragment of a treebank parse.<a name="line.73"></a>
<span class="sourceLineNo">074</span>   * @return if the string matches, then a node will be returned. Otherwise, null is returned.<a name="line.74"></a>
<span class="sourceLineNo">075</span>   */<a name="line.75"></a>
<span class="sourceLineNo">076</span>  protected static TreebankNode getLeafNode(String parseFragment) {<a name="line.76"></a>
<span class="sourceLineNo">077</span>    Matcher leafNodeMatcher = leafNodePattern.matcher(parseFragment);<a name="line.77"></a>
<span class="sourceLineNo">078</span>    if (leafNodeMatcher.matches()) {<a name="line.78"></a>
<span class="sourceLineNo">079</span>      String type = leafNodeMatcher.group(1);<a name="line.79"></a>
<span class="sourceLineNo">080</span>      String value = leafNodeMatcher.group(2);<a name="line.80"></a>
<span class="sourceLineNo">081</span>      TreebankNode node = new TreebankNode();<a name="line.81"></a>
<span class="sourceLineNo">082</span>      node.setType(getTypeFromType(type));<a name="line.82"></a>
<span class="sourceLineNo">083</span>      node.setTags(getTagsFromType(type));<a name="line.83"></a>
<span class="sourceLineNo">084</span>      node.setValue(value);<a name="line.84"></a>
<span class="sourceLineNo">085</span>      node.setLeaf(true);<a name="line.85"></a>
<span class="sourceLineNo">086</span>      // the token and the value will almost always be the same except for<a name="line.86"></a>
<span class="sourceLineNo">087</span>      // a few special values (e.g. "-RCB-", "-LCB-", and "-NONE-")<a name="line.87"></a>
<span class="sourceLineNo">088</span>      String token = getToken(node.getValue(), node.getType());<a name="line.88"></a>
<span class="sourceLineNo">089</span>      node.setText(token);<a name="line.89"></a>
<span class="sourceLineNo">090</span>      return node;<a name="line.90"></a>
<span class="sourceLineNo">091</span>    }<a name="line.91"></a>
<span class="sourceLineNo">092</span>    return null;<a name="line.92"></a>
<span class="sourceLineNo">093</span>  }<a name="line.93"></a>
<span class="sourceLineNo">094</span><a name="line.94"></a>
<span class="sourceLineNo">095</span>  private static String getTypeFromType(String fullType) {<a name="line.95"></a>
<span class="sourceLineNo">096</span>    if (fullType.startsWith("-"))<a name="line.96"></a>
<span class="sourceLineNo">097</span>      return fullType.substring(0, fullType.indexOf('-', 1) + 1);<a name="line.97"></a>
<span class="sourceLineNo">098</span><a name="line.98"></a>
<span class="sourceLineNo">099</span>    return fullType.split("[-=]")[0];<a name="line.99"></a>
<span class="sourceLineNo">100</span>  }<a name="line.100"></a>
<span class="sourceLineNo">101</span><a name="line.101"></a>
<span class="sourceLineNo">102</span>  private static String[] getTagsFromType(String fullType) {<a name="line.102"></a>
<span class="sourceLineNo">103</span>    if (fullType.startsWith("-")) {<a name="line.103"></a>
<span class="sourceLineNo">104</span>      String rest = fullType.substring(fullType.indexOf('-', 1) + 1);<a name="line.104"></a>
<span class="sourceLineNo">105</span>      if (rest.length() &gt; 0)<a name="line.105"></a>
<span class="sourceLineNo">106</span>        return rest.split("[-=]");<a name="line.106"></a>
<span class="sourceLineNo">107</span>      else<a name="line.107"></a>
<span class="sourceLineNo">108</span>        return new String[0];<a name="line.108"></a>
<span class="sourceLineNo">109</span>    } else {<a name="line.109"></a>
<span class="sourceLineNo">110</span>      String[] parts = fullType.split("[-=]");<a name="line.110"></a>
<span class="sourceLineNo">111</span>      String[] tags = new String[parts.length - 1];<a name="line.111"></a>
<span class="sourceLineNo">112</span><a name="line.112"></a>
<span class="sourceLineNo">113</span>      for (int i = 1; i &lt; parts.length; i++)<a name="line.113"></a>
<span class="sourceLineNo">114</span>        tags[i - 1] = parts[i];<a name="line.114"></a>
<span class="sourceLineNo">115</span>      return tags;<a name="line.115"></a>
<span class="sourceLineNo">116</span>    }<a name="line.116"></a>
<span class="sourceLineNo">117</span>  }<a name="line.117"></a>
<span class="sourceLineNo">118</span><a name="line.118"></a>
<span class="sourceLineNo">119</span>  /**<a name="line.119"></a>
<span class="sourceLineNo">120</span>   * used to identify the type of a consituent in a treebank parse tree. It will match strings such<a name="line.120"></a>
<span class="sourceLineNo">121</span>   * as:<a name="line.121"></a>
<span class="sourceLineNo">122</span>   * &lt;ul&gt;<a name="line.122"></a>
<span class="sourceLineNo">123</span>   * &lt;li&gt;"NNP" in "(NNP Community)"<a name="line.123"></a>
<span class="sourceLineNo">124</span>   * &lt;li&gt;":" in "(: --)"<a name="line.124"></a>
<span class="sourceLineNo">125</span>   * &lt;li&gt;"-NONE-" in "(-NONE- *U*)"<a name="line.125"></a>
<span class="sourceLineNo">126</span>   * &lt;/ul&gt;<a name="line.126"></a>
<span class="sourceLineNo">127</span>   */<a name="line.127"></a>
<span class="sourceLineNo">128</span>  public static final String TYPE_REGEX = "^\\(([^() ]+)";<a name="line.128"></a>
<span class="sourceLineNo">129</span><a name="line.129"></a>
<span class="sourceLineNo">130</span>  private static Pattern typePattern = Pattern.compile(TYPE_REGEX);<a name="line.130"></a>
<span class="sourceLineNo">131</span><a name="line.131"></a>
<span class="sourceLineNo">132</span>  /**<a name="line.132"></a>
<span class="sourceLineNo">133</span>   * Returns the type of a constituent of some fragment of a treebank parse. Assumes that the first<a name="line.133"></a>
<span class="sourceLineNo">134</span>   * character is a parenthesis. Examples:<a name="line.134"></a>
<span class="sourceLineNo">135</span>   * &lt;ul&gt;<a name="line.135"></a>
<span class="sourceLineNo">136</span>   * &lt;li&gt;parseFragment = "(NP-LOC (NNP Calif.) )" return = "NP-LOC"<a name="line.136"></a>
<span class="sourceLineNo">137</span>   * &lt;li&gt;parseFragment = "(NP" return "NP"<a name="line.137"></a>
<span class="sourceLineNo">138</span>   * &lt;li&gt;parseFragment = "(-NONE- *U*) ) (PP (IN of)" return = "-NONE-"<a name="line.138"></a>
<span class="sourceLineNo">139</span>   * &lt;/ul&gt;<a name="line.139"></a>
<span class="sourceLineNo">140</span>   * <a name="line.140"></a>
<span class="sourceLineNo">141</span>   * @param parseFragment<a name="line.141"></a>
<span class="sourceLineNo">142</span>   *          some fragment of a treebank parse<a name="line.142"></a>
<span class="sourceLineNo">143</span>   * @return the type of the constituent.<a name="line.143"></a>
<span class="sourceLineNo">144</span>   */<a name="line.144"></a>
<span class="sourceLineNo">145</span>  protected static String getType(String parseFragment) {<a name="line.145"></a>
<span class="sourceLineNo">146</span>    Matcher typeMatcher = typePattern.matcher(parseFragment);<a name="line.146"></a>
<span class="sourceLineNo">147</span>    if (typeMatcher.find())<a name="line.147"></a>
<span class="sourceLineNo">148</span>      return typeMatcher.group(1);<a name="line.148"></a>
<span class="sourceLineNo">149</span>    return null;<a name="line.149"></a>
<span class="sourceLineNo">150</span>  }<a name="line.150"></a>
<span class="sourceLineNo">151</span><a name="line.151"></a>
<span class="sourceLineNo">152</span>  public static final String cleanUPRegex1 = "\\s+";<a name="line.152"></a>
<span class="sourceLineNo">153</span><a name="line.153"></a>
<span class="sourceLineNo">154</span>  private static final Pattern cleanUpPattern1 = Pattern.compile(cleanUPRegex1, Pattern.MULTILINE);<a name="line.154"></a>
<span class="sourceLineNo">155</span><a name="line.155"></a>
<span class="sourceLineNo">156</span>  public static final String cleanUPRegex2 = "\\( \\(";<a name="line.156"></a>
<span class="sourceLineNo">157</span><a name="line.157"></a>
<span class="sourceLineNo">158</span>  private static final Pattern cleanUpPattern2 = Pattern.compile(cleanUPRegex2, Pattern.MULTILINE);<a name="line.158"></a>
<span class="sourceLineNo">159</span><a name="line.159"></a>
<span class="sourceLineNo">160</span>  public static final String cleanUPRegex3 = "\\) \\)";<a name="line.160"></a>
<span class="sourceLineNo">161</span><a name="line.161"></a>
<span class="sourceLineNo">162</span>  private static final Pattern cleanUpPattern3 = Pattern.compile(cleanUPRegex3, Pattern.MULTILINE);<a name="line.162"></a>
<span class="sourceLineNo">163</span><a name="line.163"></a>
<span class="sourceLineNo">164</span>  public static final String cleanUPRegex4 = "\\s*\\(\\s*\\(";<a name="line.164"></a>
<span class="sourceLineNo">165</span><a name="line.165"></a>
<span class="sourceLineNo">166</span>  private static final Pattern cleanUpPattern4 = Pattern.compile(cleanUPRegex4, Pattern.MULTILINE);<a name="line.166"></a>
<span class="sourceLineNo">167</span><a name="line.167"></a>
<span class="sourceLineNo">168</span>  /**<a name="line.168"></a>
<span class="sourceLineNo">169</span>   * This method was created simply as a way to clean up the parse string for a sentence in the<a name="line.169"></a>
<span class="sourceLineNo">170</span>   * treebank syntax. The most important thing that it does is add a type called TOP to the top node<a name="line.170"></a>
<span class="sourceLineNo">171</span>   * of the sentence. This simplifies parsing. The other string replacements just remove white space<a name="line.171"></a>
<span class="sourceLineNo">172</span>   * and such and are probably unnecessary. This was inspired by the OpenNLP solution which takes in<a name="line.172"></a>
<span class="sourceLineNo">173</span>   * one line at a time from a file that has been modified in this way.<a name="line.173"></a>
<span class="sourceLineNo">174</span>   * <a name="line.174"></a>
<span class="sourceLineNo">175</span>   * @param parse<a name="line.175"></a>
<span class="sourceLineNo">176</span>   *          a String in the treebank format<a name="line.176"></a>
<span class="sourceLineNo">177</span>   * @return a String in the treebank that has been cleaned up a bit.<a name="line.177"></a>
<span class="sourceLineNo">178</span>   */<a name="line.178"></a>
<span class="sourceLineNo">179</span>  public static String prepareString(String parse) {<a name="line.179"></a>
<span class="sourceLineNo">180</span>    parse = cleanUpPattern1.matcher(parse).replaceAll(" ");<a name="line.180"></a>
<span class="sourceLineNo">181</span>    parse = cleanUpPattern2.matcher(parse).replaceAll("((");<a name="line.181"></a>
<span class="sourceLineNo">182</span>    parse = cleanUpPattern3.matcher(parse).replaceAll("))");<a name="line.182"></a>
<span class="sourceLineNo">183</span>    parse = cleanUpPattern4.matcher(parse).replaceFirst("(TOP (");<a name="line.183"></a>
<span class="sourceLineNo">184</span>    return parse.trim();<a name="line.184"></a>
<span class="sourceLineNo">185</span>  }<a name="line.185"></a>
<span class="sourceLineNo">186</span><a name="line.186"></a>
<span class="sourceLineNo">187</span>  /**<a name="line.187"></a>
<span class="sourceLineNo">188</span>   * A treebank parse does not preserve whitespace information. This method provides a simple<a name="line.188"></a>
<span class="sourceLineNo">189</span>   * mechanism for inferring the original plain text of a treebank parse. If you have access to the<a name="line.189"></a>
<span class="sourceLineNo">190</span>   * original plain text, then you can bypass use of this method by calling the appropriate parse<a name="line.190"></a>
<span class="sourceLineNo">191</span>   * method.<a name="line.191"></a>
<span class="sourceLineNo">192</span>   * <a name="line.192"></a>
<span class="sourceLineNo">193</span>   * @see #parse(String, String, int)<a name="line.193"></a>
<span class="sourceLineNo">194</span>   * <a name="line.194"></a>
<span class="sourceLineNo">195</span>   * @param treebankText<a name="line.195"></a>
<span class="sourceLineNo">196</span>   *          One or more parses in Treebank parenthesized format.<a name="line.196"></a>
<span class="sourceLineNo">197</span>   * @return a "best" guess of the original plain text given in the parse.<a name="line.197"></a>
<span class="sourceLineNo">198</span>   */<a name="line.198"></a>
<span class="sourceLineNo">199</span>  public static String inferPlainText(String treebankText) {<a name="line.199"></a>
<span class="sourceLineNo">200</span>    StringBuilder sb = new StringBuilder();<a name="line.200"></a>
<span class="sourceLineNo">201</span>    for (String parse : splitSentences(treebankText)) {<a name="line.201"></a>
<span class="sourceLineNo">202</span>      Matcher matcher = leafNodePattern.matcher(parse);<a name="line.202"></a>
<span class="sourceLineNo">203</span>      while (matcher.find()) {<a name="line.203"></a>
<span class="sourceLineNo">204</span>        TreebankNode node = getLeafNode(matcher.group());<a name="line.204"></a>
<span class="sourceLineNo">205</span>        if (node.getText() != null &amp;&amp; node.getText().length() &gt; 0) {<a name="line.205"></a>
<span class="sourceLineNo">206</span>          int lastIndex = sb.length() - 1;<a name="line.206"></a>
<span class="sourceLineNo">207</span>          if (lastIndex &gt; 0 &amp;&amp; !needsSpaceBefore(node.getText()) &amp;&amp; sb.charAt(lastIndex) == ' ') {<a name="line.207"></a>
<span class="sourceLineNo">208</span>            sb.deleteCharAt(lastIndex);<a name="line.208"></a>
<span class="sourceLineNo">209</span>          }<a name="line.209"></a>
<span class="sourceLineNo">210</span>          sb.append(node.getText());<a name="line.210"></a>
<span class="sourceLineNo">211</span>          if (needsSpaceAfter(node.getText())) {<a name="line.211"></a>
<span class="sourceLineNo">212</span>            sb.append(" ");<a name="line.212"></a>
<span class="sourceLineNo">213</span>          }<a name="line.213"></a>
<span class="sourceLineNo">214</span>        }<a name="line.214"></a>
<span class="sourceLineNo">215</span>      }<a name="line.215"></a>
<span class="sourceLineNo">216</span>      int lastIndex = sb.length() - 1;<a name="line.216"></a>
<span class="sourceLineNo">217</span>      if (lastIndex &gt;= 0 &amp;&amp; sb.charAt(lastIndex) == ' ') {<a name="line.217"></a>
<span class="sourceLineNo">218</span>        sb.deleteCharAt(lastIndex);<a name="line.218"></a>
<span class="sourceLineNo">219</span>      }<a name="line.219"></a>
<span class="sourceLineNo">220</span>      sb.append('\n');<a name="line.220"></a>
<span class="sourceLineNo">221</span>    }<a name="line.221"></a>
<span class="sourceLineNo">222</span>    return sb.toString().trim();<a name="line.222"></a>
<span class="sourceLineNo">223</span>  }<a name="line.223"></a>
<span class="sourceLineNo">224</span><a name="line.224"></a>
<span class="sourceLineNo">225</span>  private static boolean needsSpaceBefore(String tokenText) {<a name="line.225"></a>
<span class="sourceLineNo">226</span>    String[] noSpaceTokens = new String[] {<a name="line.226"></a>
<span class="sourceLineNo">227</span>        ".",<a name="line.227"></a>
<span class="sourceLineNo">228</span>        ",",<a name="line.228"></a>
<span class="sourceLineNo">229</span>        ":",<a name="line.229"></a>
<span class="sourceLineNo">230</span>        ";",<a name="line.230"></a>
<span class="sourceLineNo">231</span>        "?",<a name="line.231"></a>
<span class="sourceLineNo">232</span>        "'s",<a name="line.232"></a>
<span class="sourceLineNo">233</span>        "'t",<a name="line.233"></a>
<span class="sourceLineNo">234</span>        "\"",<a name="line.234"></a>
<span class="sourceLineNo">235</span>        "!",<a name="line.235"></a>
<span class="sourceLineNo">236</span>        ")",<a name="line.236"></a>
<span class="sourceLineNo">237</span>        "]" };<a name="line.237"></a>
<span class="sourceLineNo">238</span>    for (String noSpaceToken : noSpaceTokens) {<a name="line.238"></a>
<span class="sourceLineNo">239</span>      if (tokenText.equals(noSpaceToken)) {<a name="line.239"></a>
<span class="sourceLineNo">240</span>        return false;<a name="line.240"></a>
<span class="sourceLineNo">241</span>      }<a name="line.241"></a>
<span class="sourceLineNo">242</span>    }<a name="line.242"></a>
<span class="sourceLineNo">243</span>    return true;<a name="line.243"></a>
<span class="sourceLineNo">244</span>  }<a name="line.244"></a>
<span class="sourceLineNo">245</span><a name="line.245"></a>
<span class="sourceLineNo">246</span>  private static boolean needsSpaceAfter(String tokenText) {<a name="line.246"></a>
<span class="sourceLineNo">247</span>    String[] noSpaceTokens = new String[] { "\"", "(", "[" };<a name="line.247"></a>
<span class="sourceLineNo">248</span>    for (String noSpaceToken : noSpaceTokens) {<a name="line.248"></a>
<span class="sourceLineNo">249</span>      if (tokenText.equals(noSpaceToken)) {<a name="line.249"></a>
<span class="sourceLineNo">250</span>        return false;<a name="line.250"></a>
<span class="sourceLineNo">251</span>      }<a name="line.251"></a>
<span class="sourceLineNo">252</span>    }<a name="line.252"></a>
<span class="sourceLineNo">253</span>    return true;<a name="line.253"></a>
<span class="sourceLineNo">254</span>  }<a name="line.254"></a>
<span class="sourceLineNo">255</span><a name="line.255"></a>
<span class="sourceLineNo">256</span>  /**<a name="line.256"></a>
<span class="sourceLineNo">257</span>   * Create TreebankNode objects corresponding to the given TreeBank format parse, e.g.:<a name="line.257"></a>
<span class="sourceLineNo">258</span>   * <a name="line.258"></a>
<span class="sourceLineNo">259</span>   * &lt;PRE&gt;<a name="line.259"></a>
<span class="sourceLineNo">260</span>   * ( (X (NP (NP (NML (NN Complex ) (NN trait )) (NN analysis )) (PP (IN of ) (NP (DT the ) (NN mouse ) (NN striatum )))) (: : ) (S (NP-SBJ (JJ independent ) (NNS QTLs )) (VP (VBP modulate ) (NP (NP (NN volume )) (CC and ) (NP (NN neuron ) (NN number)))))) )<a name="line.260"></a>
<span class="sourceLineNo">261</span>   * &lt;/PRE&gt;<a name="line.261"></a>
<span class="sourceLineNo">262</span>   * <a name="line.262"></a>
<span class="sourceLineNo">263</span>   * The text will be inferred automatically from the words in the parse.<a name="line.263"></a>
<span class="sourceLineNo">264</span>   * <a name="line.264"></a>
<span class="sourceLineNo">265</span>   * @param parse<a name="line.265"></a>
<span class="sourceLineNo">266</span>   *          A TreeBank formatted parse<a name="line.266"></a>
<span class="sourceLineNo">267</span>   * @return The TreebankNode root of the parse tree<a name="line.267"></a>
<span class="sourceLineNo">268</span>   * @see #inferPlainText(String)<a name="line.268"></a>
<span class="sourceLineNo">269</span>   * @see #parse(String, String, int)<a name="line.269"></a>
<span class="sourceLineNo">270</span>   */<a name="line.270"></a>
<span class="sourceLineNo">271</span>  public static TopTreebankNode parse(String parse) {<a name="line.271"></a>
<span class="sourceLineNo">272</span>    parse = prepareString(parse);<a name="line.272"></a>
<span class="sourceLineNo">273</span>    String plainText = inferPlainText(parse).trim();<a name="line.273"></a>
<span class="sourceLineNo">274</span>    return parse(parse, plainText, 0);<a name="line.274"></a>
<span class="sourceLineNo">275</span>  }<a name="line.275"></a>
<span class="sourceLineNo">276</span><a name="line.276"></a>
<span class="sourceLineNo">277</span>  private static void checkText(TreebankNode node, String text) {<a name="line.277"></a>
<span class="sourceLineNo">278</span>    String text1 = node.getText();<a name="line.278"></a>
<span class="sourceLineNo">279</span>    int start = node.getTextBegin();<a name="line.279"></a>
<span class="sourceLineNo">280</span>    int end = node.getTextEnd();<a name="line.280"></a>
<span class="sourceLineNo">281</span>    String text2 = text.substring(start, end);<a name="line.281"></a>
<span class="sourceLineNo">282</span>    if (!text1.equals(text2)) {<a name="line.282"></a>
<span class="sourceLineNo">283</span>      // TreeBank adds in (. .) nodes in odd places, e.g. when a sentence<a name="line.283"></a>
<span class="sourceLineNo">284</span>      // ends with U.S. (and no final period). As a result, we need to<a name="line.284"></a>
<span class="sourceLineNo">285</span>      // allow periods to match whitespace and adjust the node bounds.<a name="line.285"></a>
<span class="sourceLineNo">286</span>      String prefix1 = text1.substring(0, text1.length() - 1);<a name="line.286"></a>
<span class="sourceLineNo">287</span>      String prefix2 = text2.substring(0, text2.length() - 1);<a name="line.287"></a>
<span class="sourceLineNo">288</span>      if (text1.endsWith(".") &amp;&amp; prefix1.equals(prefix2)) {<a name="line.288"></a>
<span class="sourceLineNo">289</span>        node.setTextEnd(node.getTextEnd() - 1);<a name="line.289"></a>
<span class="sourceLineNo">290</span>      } else {<a name="line.290"></a>
<span class="sourceLineNo">291</span>        throw new IllegalArgumentException(<a name="line.291"></a>
<span class="sourceLineNo">292</span>            "plain text does not align with tokens in treebank parse.  node text = '" + text1<a name="line.292"></a>
<span class="sourceLineNo">293</span>                + "'  plain text = '" + text2 + "'");<a name="line.293"></a>
<span class="sourceLineNo">294</span>      }<a name="line.294"></a>
<span class="sourceLineNo">295</span>    }<a name="line.295"></a>
<span class="sourceLineNo">296</span>  }<a name="line.296"></a>
<span class="sourceLineNo">297</span><a name="line.297"></a>
<span class="sourceLineNo">298</span>  /**<a name="line.298"></a>
<span class="sourceLineNo">299</span>   * Create TreebankNode objects corresponding to the given TreeBank format parse, e.g.:<a name="line.299"></a>
<span class="sourceLineNo">300</span>   * <a name="line.300"></a>
<span class="sourceLineNo">301</span>   * &lt;PRE&gt;<a name="line.301"></a>
<span class="sourceLineNo">302</span>   * ( (X (NP (NP (NML (NN Complex ) (NN trait )) (NN analysis )) (PP (IN of ) (NP (DT the ) (NN mouse ) (NN striatum )))) (: : ) (S (NP-SBJ (JJ independent ) (NNS QTLs )) (VP (VBP modulate ) (NP (NP (NN volume )) (CC and ) (NP (NN neuron ) (NN number)))))) )<a name="line.302"></a>
<span class="sourceLineNo">303</span>   * &lt;/PRE&gt;<a name="line.303"></a>
<span class="sourceLineNo">304</span>   * <a name="line.304"></a>
<span class="sourceLineNo">305</span>   * The start and end offsets of each TreebankNode will be aligned to the word offsets in the given<a name="line.305"></a>
<span class="sourceLineNo">306</span>   * text.<a name="line.306"></a>
<span class="sourceLineNo">307</span>   * <a name="line.307"></a>
<span class="sourceLineNo">308</span>   * @param parse<a name="line.308"></a>
<span class="sourceLineNo">309</span>   *          A TreeBank formatted parse<a name="line.309"></a>
<span class="sourceLineNo">310</span>   * @param text<a name="line.310"></a>
<span class="sourceLineNo">311</span>   *          The text to which the parse should be aligned<a name="line.311"></a>
<span class="sourceLineNo">312</span>   * @param textOffset<a name="line.312"></a>
<span class="sourceLineNo">313</span>   *          The character offset at which the parse text should start to be aligned. For example,<a name="line.313"></a>
<span class="sourceLineNo">314</span>   *          if the words of the parse start right at the beginning of the text, the appropriate<a name="line.314"></a>
<span class="sourceLineNo">315</span>   *          textOffset is 0.<a name="line.315"></a>
<span class="sourceLineNo">316</span>   * @return The TreebankNode root of the parse tree. The root node will be a TopTreebankNode, and<a name="line.316"></a>
<span class="sourceLineNo">317</span>   *         all its descendants will be TreebankNodes.<a name="line.317"></a>
<span class="sourceLineNo">318</span>   * @see TopTreebankNode<a name="line.318"></a>
<span class="sourceLineNo">319</span>   * @see TreebankNode<a name="line.319"></a>
<span class="sourceLineNo">320</span>   */<a name="line.320"></a>
<span class="sourceLineNo">321</span>  public static TopTreebankNode parse(String parse, String text, int textOffset) {<a name="line.321"></a>
<span class="sourceLineNo">322</span>    try {<a name="line.322"></a>
<span class="sourceLineNo">323</span>      TopTreebankNode topNode = new TopTreebankNode();<a name="line.323"></a>
<span class="sourceLineNo">324</span>      parse = prepareString(parse);<a name="line.324"></a>
<span class="sourceLineNo">325</span>      // used to capture the plain text of the sentence.<a name="line.325"></a>
<span class="sourceLineNo">326</span>      StringBuffer consumedText = new StringBuffer();<a name="line.326"></a>
<span class="sourceLineNo">327</span>      if (text != null) {<a name="line.327"></a>
<span class="sourceLineNo">328</span>        textOffset = movePastWhiteSpaceChars(text, textOffset);<a name="line.328"></a>
<span class="sourceLineNo">329</span>        consumedText.append(text.substring(0, textOffset));<a name="line.329"></a>
<span class="sourceLineNo">330</span>      }<a name="line.330"></a>
<span class="sourceLineNo">331</span><a name="line.331"></a>
<span class="sourceLineNo">332</span>      Stack&lt;Integer&gt; parseOffsetStack = new Stack&lt;Integer&gt;();<a name="line.332"></a>
<span class="sourceLineNo">333</span>      Stack&lt;Integer&gt; plainTextOffsetStack = new Stack&lt;Integer&gt;();<a name="line.333"></a>
<span class="sourceLineNo">334</span><a name="line.334"></a>
<span class="sourceLineNo">335</span>      // keeps the nodes that are waiting for their parents to be completed.<a name="line.335"></a>
<span class="sourceLineNo">336</span>      Stack&lt;TreebankNode&gt; parseStack = new Stack&lt;TreebankNode&gt;();<a name="line.336"></a>
<span class="sourceLineNo">337</span><a name="line.337"></a>
<span class="sourceLineNo">338</span>      for (int ci = 0; ci &lt; parse.length(); ci++) {<a name="line.338"></a>
<span class="sourceLineNo">339</span>        char c = parse.charAt(ci);<a name="line.339"></a>
<span class="sourceLineNo">340</span>        if (c == '(') {<a name="line.340"></a>
<span class="sourceLineNo">341</span>          // at the start of each constituent we will push the starting<a name="line.341"></a>
<span class="sourceLineNo">342</span>          // index of it<a name="line.342"></a>
<span class="sourceLineNo">343</span>          // w.r.t. the parse string.<a name="line.343"></a>
<span class="sourceLineNo">344</span>          parseOffsetStack.push(ci);<a name="line.344"></a>
<span class="sourceLineNo">345</span>          // also push the starting index w.r.t. the plain text of the<a name="line.345"></a>
<span class="sourceLineNo">346</span>          // sentence.<a name="line.346"></a>
<span class="sourceLineNo">347</span>          plainTextOffsetStack.push(consumedText.length());<a name="line.347"></a>
<span class="sourceLineNo">348</span>        } else if (c == ')') {<a name="line.348"></a>
<span class="sourceLineNo">349</span>          int begin = parseOffsetStack.pop();<a name="line.349"></a>
<span class="sourceLineNo">350</span>          int end = ci;<a name="line.350"></a>
<span class="sourceLineNo">351</span>          // the portion of the parse string that corresponds to the<a name="line.351"></a>
<span class="sourceLineNo">352</span>          // constituent that<a name="line.352"></a>
<span class="sourceLineNo">353</span>          // we found the left bracket for ')'.<a name="line.353"></a>
<span class="sourceLineNo">354</span>          String subParse = parse.substring(begin, end + 1);<a name="line.354"></a>
<span class="sourceLineNo">355</span><a name="line.355"></a>
<span class="sourceLineNo">356</span>          int textBegin = plainTextOffsetStack.pop();<a name="line.356"></a>
<span class="sourceLineNo">357</span><a name="line.357"></a>
<span class="sourceLineNo">358</span>          TreebankNode node = getLeafNode(subParse);<a name="line.358"></a>
<span class="sourceLineNo">359</span>          if (node != null) {<a name="line.359"></a>
<span class="sourceLineNo">360</span>            node.setTopNode(topNode);<a name="line.360"></a>
<span class="sourceLineNo">361</span>            node.setParseBegin(begin);<a name="line.361"></a>
<span class="sourceLineNo">362</span>            node.setParseEnd(end + 1);<a name="line.362"></a>
<span class="sourceLineNo">363</span>            String token = node.getText();<a name="line.363"></a>
<span class="sourceLineNo">364</span><a name="line.364"></a>
<span class="sourceLineNo">365</span>            if (token.length() &gt; 0) {<a name="line.365"></a>
<span class="sourceLineNo">366</span>              int realBegin = movePastWhiteSpaceChars(text, textBegin);<a name="line.366"></a>
<span class="sourceLineNo">367</span>              consumedText.append(text.substring(textBegin, realBegin));<a name="line.367"></a>
<span class="sourceLineNo">368</span>              consumedText.append(token);<a name="line.368"></a>
<span class="sourceLineNo">369</span>              node.setTextBegin(realBegin);<a name="line.369"></a>
<span class="sourceLineNo">370</span>              node.setTextEnd(realBegin + token.length());<a name="line.370"></a>
<span class="sourceLineNo">371</span><a name="line.371"></a>
<span class="sourceLineNo">372</span>            } else {<a name="line.372"></a>
<span class="sourceLineNo">373</span>              node.setTextBegin(textBegin);<a name="line.373"></a>
<span class="sourceLineNo">374</span>              node.setTextEnd(textBegin + token.length());<a name="line.374"></a>
<span class="sourceLineNo">375</span>            }<a name="line.375"></a>
<span class="sourceLineNo">376</span>            checkText(node, text);<a name="line.376"></a>
<span class="sourceLineNo">377</span>            parseStack.push(node);<a name="line.377"></a>
<span class="sourceLineNo">378</span>          } else {<a name="line.378"></a>
<span class="sourceLineNo">379</span>            if (parse.lastIndexOf(')') == ci) // the last ')' is the top<a name="line.379"></a>
<span class="sourceLineNo">380</span>              // node.<a name="line.380"></a>
<span class="sourceLineNo">381</span>              node = topNode; // this is the instance that will be<a name="line.381"></a>
<span class="sourceLineNo">382</span>            // returned.<a name="line.382"></a>
<span class="sourceLineNo">383</span>            else<a name="line.383"></a>
<span class="sourceLineNo">384</span>              node = new TreebankNode();<a name="line.384"></a>
<span class="sourceLineNo">385</span>            node.setTopNode(topNode);<a name="line.385"></a>
<span class="sourceLineNo">386</span>            node.setParseBegin(begin);<a name="line.386"></a>
<span class="sourceLineNo">387</span>            node.setParseEnd(end + 1);<a name="line.387"></a>
<span class="sourceLineNo">388</span>            String type = getType(subParse);<a name="line.388"></a>
<span class="sourceLineNo">389</span>            node.setType(getTypeFromType(type));<a name="line.389"></a>
<span class="sourceLineNo">390</span>            node.setTags(getTagsFromType(type));<a name="line.390"></a>
<span class="sourceLineNo">391</span>            node.setLeaf(false);<a name="line.391"></a>
<span class="sourceLineNo">392</span>            // keep adding the nodes on the stack until it is empty or<a name="line.392"></a>
<span class="sourceLineNo">393</span>            // the next node on the stack starts before the current node<a name="line.393"></a>
<span class="sourceLineNo">394</span>            // (i.e. has a different<a name="line.394"></a>
<span class="sourceLineNo">395</span>            // parent than the current node that will be completed<a name="line.395"></a>
<span class="sourceLineNo">396</span>            // later.)<a name="line.396"></a>
<span class="sourceLineNo">397</span>            while (parseStack.size() &gt; 0<a name="line.397"></a>
<span class="sourceLineNo">398</span>                &amp;&amp; parseStack.peek().getParseBegin() &gt; node.getParseBegin()) {<a name="line.398"></a>
<span class="sourceLineNo">399</span>              TreebankNode child = parseStack.pop();<a name="line.399"></a>
<span class="sourceLineNo">400</span>              node.addChild(child);<a name="line.400"></a>
<span class="sourceLineNo">401</span>              child.setParent(node);<a name="line.401"></a>
<span class="sourceLineNo">402</span>            }<a name="line.402"></a>
<span class="sourceLineNo">403</span>            // we typically add a token followed by a space to<a name="line.403"></a>
<span class="sourceLineNo">404</span>            // plainText, except when the<a name="line.404"></a>
<span class="sourceLineNo">405</span>            // token is an empty string as it is when the corresponding<a name="line.405"></a>
<span class="sourceLineNo">406</span>            // type is -NONE-<a name="line.406"></a>
<span class="sourceLineNo">407</span>            int realBegin = movePastWhiteSpaceChars(text, textBegin);<a name="line.407"></a>
<span class="sourceLineNo">408</span>            node.setTextBegin(realBegin);<a name="line.408"></a>
<span class="sourceLineNo">409</span>            node.setTextEnd(Math.max(realBegin, consumedText.length()));<a name="line.409"></a>
<span class="sourceLineNo">410</span><a name="line.410"></a>
<span class="sourceLineNo">411</span>            try {<a name="line.411"></a>
<span class="sourceLineNo">412</span>              node.setText(consumedText.substring(node.getTextBegin(), node.getTextEnd()));<a name="line.412"></a>
<span class="sourceLineNo">413</span>            } catch (StringIndexOutOfBoundsException sioobe) {<a name="line.413"></a>
<span class="sourceLineNo">414</span>              node.setText("");<a name="line.414"></a>
<span class="sourceLineNo">415</span>            }<a name="line.415"></a>
<span class="sourceLineNo">416</span>            checkText(node, text);<a name="line.416"></a>
<span class="sourceLineNo">417</span>            parseStack.push(node);<a name="line.417"></a>
<span class="sourceLineNo">418</span>          }<a name="line.418"></a>
<span class="sourceLineNo">419</span>        }<a name="line.419"></a>
<span class="sourceLineNo">420</span>      }<a name="line.420"></a>
<span class="sourceLineNo">421</span><a name="line.421"></a>
<span class="sourceLineNo">422</span>      topNode.setTreebankParse(parse);<a name="line.422"></a>
<span class="sourceLineNo">423</span>      topNode.initTerminalNodes();<a name="line.423"></a>
<span class="sourceLineNo">424</span>      return topNode;<a name="line.424"></a>
<span class="sourceLineNo">425</span>    } catch (RuntimeException e) {<a name="line.425"></a>
<span class="sourceLineNo">426</span>      throw new IllegalArgumentException("exception thrown when parsing the following: " + parse, e);<a name="line.426"></a>
<span class="sourceLineNo">427</span>    }<a name="line.427"></a>
<span class="sourceLineNo">428</span>  }<a name="line.428"></a>
<span class="sourceLineNo">429</span><a name="line.429"></a>
<span class="sourceLineNo">430</span>  private static final Pattern nonwhiteSpaceCharPattern = Pattern.compile("[^\\s]");<a name="line.430"></a>
<span class="sourceLineNo">431</span><a name="line.431"></a>
<span class="sourceLineNo">432</span>  public static int movePastWhiteSpaceChars(String text, int textOffset) {<a name="line.432"></a>
<span class="sourceLineNo">433</span>    Matcher matcher = nonwhiteSpaceCharPattern.matcher(text);<a name="line.433"></a>
<span class="sourceLineNo">434</span>    if (matcher.find(textOffset)) {<a name="line.434"></a>
<span class="sourceLineNo">435</span>      return matcher.start();<a name="line.435"></a>
<span class="sourceLineNo">436</span>    }<a name="line.436"></a>
<span class="sourceLineNo">437</span>    return textOffset;<a name="line.437"></a>
<span class="sourceLineNo">438</span>  }<a name="line.438"></a>
<span class="sourceLineNo">439</span><a name="line.439"></a>
<span class="sourceLineNo">440</span>  /**<a name="line.440"></a>
<span class="sourceLineNo">441</span>   * Replace specially encoded tokens with their original textual representation.<a name="line.441"></a>
<span class="sourceLineNo">442</span>   * (http://www.cis.upenn.edu/~treebank/tokenization.html)<a name="line.442"></a>
<span class="sourceLineNo">443</span>   * <a name="line.443"></a>
<span class="sourceLineNo">444</span>   * @param value<a name="line.444"></a>
<span class="sourceLineNo">445</span>   * @param type<a name="line.445"></a>
<span class="sourceLineNo">446</span>   * @return The string in its original textual representation.<a name="line.446"></a>
<span class="sourceLineNo">447</span>   */<a name="line.447"></a>
<span class="sourceLineNo">448</span>  private static String getToken(String value, String type) {<a name="line.448"></a>
<span class="sourceLineNo">449</span>    value = value.replace("-RCB-", "}");<a name="line.449"></a>
<span class="sourceLineNo">450</span>    value = value.replace("-LCB-", "{");<a name="line.450"></a>
<span class="sourceLineNo">451</span>    value = value.replace("-RRB-", ")");<a name="line.451"></a>
<span class="sourceLineNo">452</span>    value = value.replace("-LRB-", "(");<a name="line.452"></a>
<span class="sourceLineNo">453</span>    value = value.replace("-RSB-", "]");<a name="line.453"></a>
<span class="sourceLineNo">454</span>    value = value.replace("-LSB-", "[");<a name="line.454"></a>
<span class="sourceLineNo">455</span>    value = value.replace("``", "\"");<a name="line.455"></a>
<span class="sourceLineNo">456</span>    value = value.replace("''", "\"");<a name="line.456"></a>
<span class="sourceLineNo">457</span><a name="line.457"></a>
<span class="sourceLineNo">458</span>    if (type.equals("-NONE-"))<a name="line.458"></a>
<span class="sourceLineNo">459</span>      return "";<a name="line.459"></a>
<span class="sourceLineNo">460</span><a name="line.460"></a>
<span class="sourceLineNo">461</span>    if (value.contains("\\/"))<a name="line.461"></a>
<span class="sourceLineNo">462</span>      return value.replace("\\/", "/");<a name="line.462"></a>
<span class="sourceLineNo">463</span><a name="line.463"></a>
<span class="sourceLineNo">464</span>    return value;<a name="line.464"></a>
<span class="sourceLineNo">465</span>  }<a name="line.465"></a>
<span class="sourceLineNo">466</span><a name="line.466"></a>
<span class="sourceLineNo">467</span>  /**<a name="line.467"></a>
<span class="sourceLineNo">468</span>   * Generally speaking, we expect one treebanked sentence per line. This method will simply return<a name="line.468"></a>
<span class="sourceLineNo">469</span>   * the lines of a document assuming that each line has matching parentheses. However, the native<a name="line.469"></a>
<span class="sourceLineNo">470</span>   * penn treebank data contains parsed sentences that are broken up across multiple lines. Each<a name="line.470"></a>
<span class="sourceLineNo">471</span>   * sentence in the PTB starts with "( (S..." and so we split on this to get the sentences. If this<a name="line.471"></a>
<span class="sourceLineNo">472</span>   * method sees "( (S...", then it will return the contents split on that pattern. If not, it will<a name="line.472"></a>
<span class="sourceLineNo">473</span>   * return the lines of the input string.<a name="line.473"></a>
<span class="sourceLineNo">474</span>   * <a name="line.474"></a>
<span class="sourceLineNo">475</span>   * Splits an .mrg file (e.g. wsj/mrg/00/wsj_0020.mrg) into sentence parses.<a name="line.475"></a>
<span class="sourceLineNo">476</span>   * <a name="line.476"></a>
<span class="sourceLineNo">477</span>   * @return individual sentence parses from treebank - i.e. strings of the form "( (S..."<a name="line.477"></a>
<span class="sourceLineNo">478</span>   */<a name="line.478"></a>
<span class="sourceLineNo">479</span><a name="line.479"></a>
<span class="sourceLineNo">480</span>  public static String[] splitSentences(String mrgContents) {<a name="line.480"></a>
<span class="sourceLineNo">481</span>    // Splitting on this regular expression can cause the first value<a name="line.481"></a>
<span class="sourceLineNo">482</span>    // in the array to be an empty string if e.g. the first line of the file<a name="line.482"></a>
<span class="sourceLineNo">483</span>    // is blank<a name="line.483"></a>
<span class="sourceLineNo">484</span>    String[] contents = mrgContents.split("(?=\\(\\s*\\()");<a name="line.484"></a>
<span class="sourceLineNo">485</span>    if (contents.length &gt; 1) {<a name="line.485"></a>
<span class="sourceLineNo">486</span>      if (contents.length &gt; 0 &amp;&amp; contents[0].trim().equals("")) {<a name="line.486"></a>
<span class="sourceLineNo">487</span>        String[] returnValues = new String[contents.length - 1];<a name="line.487"></a>
<span class="sourceLineNo">488</span>        System.arraycopy(contents, 1, returnValues, 0, returnValues.length);<a name="line.488"></a>
<span class="sourceLineNo">489</span>        return returnValues;<a name="line.489"></a>
<span class="sourceLineNo">490</span>      } else {<a name="line.490"></a>
<span class="sourceLineNo">491</span>        String[] returnValues = new String[contents.length];<a name="line.491"></a>
<span class="sourceLineNo">492</span>        System.arraycopy(contents, 0, returnValues, 0, returnValues.length);<a name="line.492"></a>
<span class="sourceLineNo">493</span>        return returnValues;<a name="line.493"></a>
<span class="sourceLineNo">494</span>      }<a name="line.494"></a>
<span class="sourceLineNo">495</span>    }<a name="line.495"></a>
<span class="sourceLineNo">496</span><a name="line.496"></a>
<span class="sourceLineNo">497</span>    String[] lines = mrgContents.split("\r?\n");<a name="line.497"></a>
<span class="sourceLineNo">498</span>    for (String line : lines) {<a name="line.498"></a>
<span class="sourceLineNo">499</span>      if (!parensMatch(line)) {<a name="line.499"></a>
<span class="sourceLineNo">500</span>        throw new IllegalArgumentException(<a name="line.500"></a>
<span class="sourceLineNo">501</span>            "Parentheses counts do not match for treebank sentence: " + line);<a name="line.501"></a>
<span class="sourceLineNo">502</span>      }<a name="line.502"></a>
<span class="sourceLineNo">503</span>    }<a name="line.503"></a>
<span class="sourceLineNo">504</span>    return lines;<a name="line.504"></a>
<span class="sourceLineNo">505</span>  }<a name="line.505"></a>
<span class="sourceLineNo">506</span><a name="line.506"></a>
<span class="sourceLineNo">507</span>  public static boolean parensMatch(String contents) {<a name="line.507"></a>
<span class="sourceLineNo">508</span>    int leftParenCount = 0;<a name="line.508"></a>
<span class="sourceLineNo">509</span>    int rightParenCount = 0;<a name="line.509"></a>
<span class="sourceLineNo">510</span><a name="line.510"></a>
<span class="sourceLineNo">511</span>    for (char c : contents.toCharArray()) {<a name="line.511"></a>
<span class="sourceLineNo">512</span>      if (c == '(')<a name="line.512"></a>
<span class="sourceLineNo">513</span>        leftParenCount++;<a name="line.513"></a>
<span class="sourceLineNo">514</span>      if (c == ')')<a name="line.514"></a>
<span class="sourceLineNo">515</span>        rightParenCount++;<a name="line.515"></a>
<span class="sourceLineNo">516</span>    }<a name="line.516"></a>
<span class="sourceLineNo">517</span><a name="line.517"></a>
<span class="sourceLineNo">518</span>    return leftParenCount == rightParenCount;<a name="line.518"></a>
<span class="sourceLineNo">519</span><a name="line.519"></a>
<span class="sourceLineNo">520</span>  }<a name="line.520"></a>
<span class="sourceLineNo">521</span><a name="line.521"></a>
<span class="sourceLineNo">522</span>  /**<a name="line.522"></a>
<span class="sourceLineNo">523</span>   * This method parses an entire documents worth of treebanked sentences.<a name="line.523"></a>
<span class="sourceLineNo">524</span>   * <a name="line.524"></a>
<span class="sourceLineNo">525</span>   * @param parse<a name="line.525"></a>
<span class="sourceLineNo">526</span>   *          a single document provided as treebank parenthesized parses<a name="line.526"></a>
<span class="sourceLineNo">527</span>   * @param textOffset<a name="line.527"></a>
<span class="sourceLineNo">528</span>   *          a value that corresponds to the character offset of the first character of the<a name="line.528"></a>
<span class="sourceLineNo">529</span>   *          document. The appropriate value for this method will typically be 0.<a name="line.529"></a>
<span class="sourceLineNo">530</span>   * @param text<a name="line.530"></a>
<span class="sourceLineNo">531</span>   *          a single document provided as plain text. If you do not have access to the original<a name="line.531"></a>
<span class="sourceLineNo">532</span>   *          plain text of the document, you can generate some using<a name="line.532"></a>
<span class="sourceLineNo">533</span>   *          {@link #inferPlainText(String)}.<a name="line.533"></a>
<span class="sourceLineNo">534</span>   */<a name="line.534"></a>
<span class="sourceLineNo">535</span>  public static List&lt;TopTreebankNode&gt; parseDocument(String parse, int textOffset, String text) {<a name="line.535"></a>
<span class="sourceLineNo">536</span>    List&lt;TopTreebankNode&gt; returnValues = new ArrayList&lt;TopTreebankNode&gt;();<a name="line.536"></a>
<span class="sourceLineNo">537</span>    String[] sentenceParses = splitSentences(parse);<a name="line.537"></a>
<span class="sourceLineNo">538</span><a name="line.538"></a>
<span class="sourceLineNo">539</span>    for (String sentenceParse : sentenceParses) {<a name="line.539"></a>
<span class="sourceLineNo">540</span>      TopTreebankNode topNode = parse(sentenceParse, text, textOffset);<a name="line.540"></a>
<span class="sourceLineNo">541</span>      textOffset = topNode.getTextEnd();<a name="line.541"></a>
<span class="sourceLineNo">542</span>      returnValues.add(topNode);<a name="line.542"></a>
<span class="sourceLineNo">543</span>    }<a name="line.543"></a>
<span class="sourceLineNo">544</span>    return returnValues;<a name="line.544"></a>
<span class="sourceLineNo">545</span>  }<a name="line.545"></a>
<span class="sourceLineNo">546</span><a name="line.546"></a>
<span class="sourceLineNo">547</span>}<a name="line.547"></a>




























































</pre>
</div>
</body>
</html>
