<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
<title>Source code</title>
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
</head>
<body>
<div class="sourceContainer">
<pre><span class="sourceLineNo">001</span>/** <a name="line.1"></a>
<span class="sourceLineNo">002</span> * Copyright (c) 2007-2008, Regents of the University of Colorado <a name="line.2"></a>
<span class="sourceLineNo">003</span> * All rights reserved.<a name="line.3"></a>
<span class="sourceLineNo">004</span> * <a name="line.4"></a>
<span class="sourceLineNo">005</span> * Redistribution and use in source and binary forms, with or without<a name="line.5"></a>
<span class="sourceLineNo">006</span> * modification, are permitted provided that the following conditions are met:<a name="line.6"></a>
<span class="sourceLineNo">007</span> * <a name="line.7"></a>
<span class="sourceLineNo">008</span> * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. <a name="line.8"></a>
<span class="sourceLineNo">009</span> * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. <a name="line.9"></a>
<span class="sourceLineNo">010</span> * Neither the name of the University of Colorado at Boulder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. <a name="line.10"></a>
<span class="sourceLineNo">011</span> * <a name="line.11"></a>
<span class="sourceLineNo">012</span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"<a name="line.12"></a>
<span class="sourceLineNo">013</span> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE<a name="line.13"></a>
<span class="sourceLineNo">014</span> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<a name="line.14"></a>
<span class="sourceLineNo">015</span> * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE<a name="line.15"></a>
<span class="sourceLineNo">016</span> * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR<a name="line.16"></a>
<span class="sourceLineNo">017</span> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF<a name="line.17"></a>
<span class="sourceLineNo">018</span> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS<a name="line.18"></a>
<span class="sourceLineNo">019</span> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN<a name="line.19"></a>
<span class="sourceLineNo">020</span> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)<a name="line.20"></a>
<span class="sourceLineNo">021</span> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE<a name="line.21"></a>
<span class="sourceLineNo">022</span> * POSSIBILITY OF SUCH DAMAGE. <a name="line.22"></a>
<span class="sourceLineNo">023</span> */<a name="line.23"></a>
<span class="sourceLineNo">024</span>package org.cleartk.srl;<a name="line.24"></a>
<span class="sourceLineNo">025</span><a name="line.25"></a>
<span class="sourceLineNo">026</span>import java.io.File;<a name="line.26"></a>
<span class="sourceLineNo">027</span>import java.util.ArrayList;<a name="line.27"></a>
<span class="sourceLineNo">028</span>import java.util.Collection;<a name="line.28"></a>
<span class="sourceLineNo">029</span>import java.util.List;<a name="line.29"></a>
<span class="sourceLineNo">030</span>import java.util.logging.Logger;<a name="line.30"></a>
<span class="sourceLineNo">031</span><a name="line.31"></a>
<span class="sourceLineNo">032</span>import org.apache.uima.UimaContext;<a name="line.32"></a>
<span class="sourceLineNo">033</span>import org.apache.uima.analysis_engine.AnalysisEngineDescription;<a name="line.33"></a>
<span class="sourceLineNo">034</span>import org.apache.uima.analysis_engine.AnalysisEngineProcessException;<a name="line.34"></a>
<span class="sourceLineNo">035</span>import org.apache.uima.jcas.JCas;<a name="line.35"></a>
<span class="sourceLineNo">036</span>import org.apache.uima.resource.ResourceInitializationException;<a name="line.36"></a>
<span class="sourceLineNo">037</span>import org.cleartk.classifier.CleartkAnnotator;<a name="line.37"></a>
<span class="sourceLineNo">038</span>import org.cleartk.classifier.DataWriterFactory;<a name="line.38"></a>
<span class="sourceLineNo">039</span>import org.cleartk.classifier.Feature;<a name="line.39"></a>
<span class="sourceLineNo">040</span>import org.cleartk.classifier.Instance;<a name="line.40"></a>
<span class="sourceLineNo">041</span>import org.cleartk.classifier.feature.extractor.CleartkExtractor;<a name="line.41"></a>
<span class="sourceLineNo">042</span>import org.cleartk.classifier.feature.extractor.CleartkExtractor.FirstCovered;<a name="line.42"></a>
<span class="sourceLineNo">043</span>import org.cleartk.classifier.feature.extractor.CleartkExtractor.LastCovered;<a name="line.43"></a>
<span class="sourceLineNo">044</span>import org.cleartk.classifier.feature.extractor.CleartkExtractorException;<a name="line.44"></a>
<span class="sourceLineNo">045</span>import org.cleartk.classifier.feature.extractor.annotationpair.AnnotationPairFeatureExtractor;<a name="line.45"></a>
<span class="sourceLineNo">046</span>import org.cleartk.classifier.feature.extractor.annotationpair.MatchingAnnotationPairExtractor;<a name="line.46"></a>
<span class="sourceLineNo">047</span>import org.cleartk.classifier.feature.extractor.annotationpair.NamingAnnotationPairFeatureExtractor;<a name="line.47"></a>
<span class="sourceLineNo">048</span>import org.cleartk.classifier.feature.extractor.annotationpair.RelativePositionExtractor;<a name="line.48"></a>
<span class="sourceLineNo">049</span>import org.cleartk.classifier.feature.extractor.simple.CoveredTextExtractor;<a name="line.49"></a>
<span class="sourceLineNo">050</span>import org.cleartk.classifier.feature.extractor.simple.MatchingAnnotationExtractor;<a name="line.50"></a>
<span class="sourceLineNo">051</span>import org.cleartk.classifier.feature.extractor.simple.NamingExtractor;<a name="line.51"></a>
<span class="sourceLineNo">052</span>import org.cleartk.classifier.feature.extractor.simple.SimpleFeatureExtractor;<a name="line.52"></a>
<span class="sourceLineNo">053</span>import org.cleartk.classifier.jar.DirectoryDataWriterFactory;<a name="line.53"></a>
<span class="sourceLineNo">054</span>import org.cleartk.classifier.jar.GenericJarClassifierFactory;<a name="line.54"></a>
<span class="sourceLineNo">055</span>import org.cleartk.srl.feature.NamedEntityExtractor;<a name="line.55"></a>
<span class="sourceLineNo">056</span>import org.cleartk.srl.feature.NodeTypeExtractor;<a name="line.56"></a>
<span class="sourceLineNo">057</span>import org.cleartk.srl.feature.POSExtractor;<a name="line.57"></a>
<span class="sourceLineNo">058</span>import org.cleartk.srl.feature.StemExtractor;<a name="line.58"></a>
<span class="sourceLineNo">059</span>import org.cleartk.srl.type.Argument;<a name="line.59"></a>
<span class="sourceLineNo">060</span>import org.cleartk.srl.type.Predicate;<a name="line.60"></a>
<span class="sourceLineNo">061</span>import org.cleartk.srl.type.SemanticArgument;<a name="line.61"></a>
<span class="sourceLineNo">062</span>import org.cleartk.syntax.constituent.type.TopTreebankNode;<a name="line.62"></a>
<span class="sourceLineNo">063</span>import org.cleartk.syntax.constituent.type.TreebankNode;<a name="line.63"></a>
<span class="sourceLineNo">064</span>import org.cleartk.syntax.feature.HeadWordExtractor;<a name="line.64"></a>
<span class="sourceLineNo">065</span>import org.cleartk.syntax.feature.SubCategorizationExtractor;<a name="line.65"></a>
<span class="sourceLineNo">066</span>import org.cleartk.syntax.feature.SyntacticPathExtractor;<a name="line.66"></a>
<span class="sourceLineNo">067</span>import org.cleartk.token.type.Sentence;<a name="line.67"></a>
<span class="sourceLineNo">068</span>import org.cleartk.token.type.Token;<a name="line.68"></a>
<span class="sourceLineNo">069</span>import org.cleartk.util.AnnotationUtil;<a name="line.69"></a>
<span class="sourceLineNo">070</span>import org.cleartk.util.UIMAUtil;<a name="line.70"></a>
<span class="sourceLineNo">071</span>import org.uimafit.factory.AnalysisEngineFactory;<a name="line.71"></a>
<span class="sourceLineNo">072</span>import org.uimafit.util.JCasUtil;<a name="line.72"></a>
<span class="sourceLineNo">073</span><a name="line.73"></a>
<span class="sourceLineNo">074</span>/**<a name="line.74"></a>
<span class="sourceLineNo">075</span> * &lt;br&gt;<a name="line.75"></a>
<span class="sourceLineNo">076</span> * Copyright (c) 2007-2008, Regents of the University of Colorado &lt;br&gt;<a name="line.76"></a>
<span class="sourceLineNo">077</span> * All rights reserved.<a name="line.77"></a>
<span class="sourceLineNo">078</span> * <a name="line.78"></a>
<span class="sourceLineNo">079</span> * <a name="line.79"></a>
<span class="sourceLineNo">080</span> * &lt;p&gt;<a name="line.80"></a>
<span class="sourceLineNo">081</span> * ArgumentIdentifier can work in 3 modes: &lt;il&gt;<a name="line.81"></a>
<span class="sourceLineNo">082</span> * &lt;li&gt;&lt;b&gt;training mode&lt;/b&gt;: take in fully annotated Propbank style data and generate training data<a name="line.82"></a>
<span class="sourceLineNo">083</span> * for detection of arguments&lt;/li&gt;<a name="line.83"></a>
<span class="sourceLineNo">084</span> * &lt;li&gt;&lt;b&gt;filter mode&lt;/b&gt;: take in fully annotated Propbank style data and a model, then add<a name="line.84"></a>
<span class="sourceLineNo">085</span> * annotations for falsely detected arguments, and remove annotations for missed arguments; this is<a name="line.85"></a>
<span class="sourceLineNo">086</span> * to facilitate training of AnnotationClassifier&lt;/li&gt;<a name="line.86"></a>
<span class="sourceLineNo">087</span> * &lt;li&gt;&lt;b&gt;annotation mode&lt;/b&gt;: take in unlabeled Treebank style data and annotate all detected<a name="line.87"></a>
<span class="sourceLineNo">088</span> * arguments (no labeling is done by this annotator)&lt;/li&gt;<a name="line.88"></a>
<span class="sourceLineNo">089</span> * &lt;/il&gt;<a name="line.89"></a>
<span class="sourceLineNo">090</span> * &lt;/p&gt;<a name="line.90"></a>
<span class="sourceLineNo">091</span> * <a name="line.91"></a>
<span class="sourceLineNo">092</span> * @author Philipp Wetzler, Philip Ogren<a name="line.92"></a>
<span class="sourceLineNo">093</span> */<a name="line.93"></a>
<span class="sourceLineNo">094</span>public class ArgumentIdentifier extends CleartkAnnotator&lt;Boolean&gt; {<a name="line.94"></a>
<span class="sourceLineNo">095</span><a name="line.95"></a>
<span class="sourceLineNo">096</span>  public static AnalysisEngineDescription getWriterDescription(<a name="line.96"></a>
<span class="sourceLineNo">097</span>      Class&lt;? extends DataWriterFactory&lt;Boolean&gt;&gt; dataWriterFactoryClass,<a name="line.97"></a>
<span class="sourceLineNo">098</span>      File outputDirectory) throws ResourceInitializationException {<a name="line.98"></a>
<span class="sourceLineNo">099</span>    return AnalysisEngineFactory.createPrimitiveDescription(<a name="line.99"></a>
<span class="sourceLineNo">100</span>        ArgumentIdentifier.class,<a name="line.100"></a>
<span class="sourceLineNo">101</span>        CleartkAnnotator.PARAM_DATA_WRITER_FACTORY_CLASS_NAME,<a name="line.101"></a>
<span class="sourceLineNo">102</span>        dataWriterFactoryClass.getName(),<a name="line.102"></a>
<span class="sourceLineNo">103</span>        DirectoryDataWriterFactory.PARAM_OUTPUT_DIRECTORY,<a name="line.103"></a>
<span class="sourceLineNo">104</span>        outputDirectory.toString());<a name="line.104"></a>
<span class="sourceLineNo">105</span>  }<a name="line.105"></a>
<span class="sourceLineNo">106</span><a name="line.106"></a>
<span class="sourceLineNo">107</span>  public static AnalysisEngineDescription getClassifierDescription(File classifierJar)<a name="line.107"></a>
<span class="sourceLineNo">108</span>      throws ResourceInitializationException {<a name="line.108"></a>
<span class="sourceLineNo">109</span>    return AnalysisEngineFactory.createPrimitiveDescription(<a name="line.109"></a>
<span class="sourceLineNo">110</span>        ArgumentIdentifier.class,<a name="line.110"></a>
<span class="sourceLineNo">111</span>        GenericJarClassifierFactory.PARAM_CLASSIFIER_JAR_PATH,<a name="line.111"></a>
<span class="sourceLineNo">112</span>        classifierJar.toString());<a name="line.112"></a>
<span class="sourceLineNo">113</span>  }<a name="line.113"></a>
<span class="sourceLineNo">114</span><a name="line.114"></a>
<span class="sourceLineNo">115</span>  @Override<a name="line.115"></a>
<span class="sourceLineNo">116</span>  public void initialize(UimaContext context) throws ResourceInitializationException {<a name="line.116"></a>
<span class="sourceLineNo">117</span>    super.initialize(context);<a name="line.117"></a>
<span class="sourceLineNo">118</span><a name="line.118"></a>
<span class="sourceLineNo">119</span>    SimpleFeatureExtractor defaultTokenExtractorSet = new MatchingAnnotationExtractor(<a name="line.119"></a>
<span class="sourceLineNo">120</span>        Token.class,<a name="line.120"></a>
<span class="sourceLineNo">121</span>        new CoveredTextExtractor(),<a name="line.121"></a>
<span class="sourceLineNo">122</span>        new StemExtractor(),<a name="line.122"></a>
<span class="sourceLineNo">123</span>        new POSExtractor());<a name="line.123"></a>
<span class="sourceLineNo">124</span><a name="line.124"></a>
<span class="sourceLineNo">125</span>    this.perPredicateExtractor = new NamingExtractor("Predicate", new MatchingAnnotationExtractor(<a name="line.125"></a>
<span class="sourceLineNo">126</span>        Token.class,<a name="line.126"></a>
<span class="sourceLineNo">127</span>        defaultTokenExtractorSet), new MatchingAnnotationExtractor(<a name="line.127"></a>
<span class="sourceLineNo">128</span>        TreebankNode.class,<a name="line.128"></a>
<span class="sourceLineNo">129</span>        new SubCategorizationExtractor()));<a name="line.129"></a>
<span class="sourceLineNo">130</span><a name="line.130"></a>
<span class="sourceLineNo">131</span>    this.perConstituentExtractor = new NamingExtractor("Constituent", new NodeTypeExtractor(),<a name="line.131"></a>
<span class="sourceLineNo">132</span>    // new TypePathExtractor(TreebankNode.class, "nodeTags"),<a name="line.132"></a>
<span class="sourceLineNo">133</span>        new HeadWordExtractor(defaultTokenExtractorSet),<a name="line.133"></a>
<span class="sourceLineNo">134</span>        new CleartkExtractor(Token.class, defaultTokenExtractorSet, new FirstCovered(1)),<a name="line.134"></a>
<span class="sourceLineNo">135</span>        new CleartkExtractor(Token.class, defaultTokenExtractorSet, new LastCovered(1)),<a name="line.135"></a>
<span class="sourceLineNo">136</span>        new NamedEntityExtractor());<a name="line.136"></a>
<span class="sourceLineNo">137</span><a name="line.137"></a>
<span class="sourceLineNo">138</span>    this.perPredicatAndConstituentExtractor = new NamingAnnotationPairFeatureExtractor(<a name="line.138"></a>
<span class="sourceLineNo">139</span>        "PredicateAndConstituent",<a name="line.139"></a>
<span class="sourceLineNo">140</span>        new MatchingAnnotationPairExtractor(<a name="line.140"></a>
<span class="sourceLineNo">141</span>            TreebankNode.class,<a name="line.141"></a>
<span class="sourceLineNo">142</span>            TreebankNode.class,<a name="line.142"></a>
<span class="sourceLineNo">143</span>            new SyntacticPathExtractor(new NodeTypeExtractor()),<a name="line.143"></a>
<span class="sourceLineNo">144</span>            new RelativePositionExtractor()));<a name="line.144"></a>
<span class="sourceLineNo">145</span>  }<a name="line.145"></a>
<span class="sourceLineNo">146</span><a name="line.146"></a>
<span class="sourceLineNo">147</span>  @Override<a name="line.147"></a>
<span class="sourceLineNo">148</span>  public void process(JCas jCas) throws AnalysisEngineProcessException {<a name="line.148"></a>
<span class="sourceLineNo">149</span>    /*<a name="line.149"></a>
<span class="sourceLineNo">150</span>     * Iterate over sentences in document<a name="line.150"></a>
<span class="sourceLineNo">151</span>     */<a name="line.151"></a>
<span class="sourceLineNo">152</span>    Collection&lt;Sentence&gt; sentences = JCasUtil.select(jCas, Sentence.class);<a name="line.152"></a>
<span class="sourceLineNo">153</span><a name="line.153"></a>
<span class="sourceLineNo">154</span>    nSentences = 0;<a name="line.154"></a>
<span class="sourceLineNo">155</span>    nPredicates = 0;<a name="line.155"></a>
<span class="sourceLineNo">156</span>    nConstituents = 0;<a name="line.156"></a>
<span class="sourceLineNo">157</span><a name="line.157"></a>
<span class="sourceLineNo">158</span>    for (Sentence sentence : sentences) {<a name="line.158"></a>
<span class="sourceLineNo">159</span>      processSentence(jCas, sentence);<a name="line.159"></a>
<span class="sourceLineNo">160</span>    }<a name="line.160"></a>
<span class="sourceLineNo">161</span><a name="line.161"></a>
<span class="sourceLineNo">162</span>    logger.info(String.format(<a name="line.162"></a>
<span class="sourceLineNo">163</span>        "processed %d sentences, %d predicates, ~%d constituents per predicate",<a name="line.163"></a>
<span class="sourceLineNo">164</span>        nSentences,<a name="line.164"></a>
<span class="sourceLineNo">165</span>        nPredicates,<a name="line.165"></a>
<span class="sourceLineNo">166</span>        nPredicates == 0 ? 0 : nConstituents / nPredicates));<a name="line.166"></a>
<span class="sourceLineNo">167</span>  }<a name="line.167"></a>
<span class="sourceLineNo">168</span><a name="line.168"></a>
<span class="sourceLineNo">169</span>  void processSentence(JCas jCas, Sentence sentence) throws AnalysisEngineProcessException {<a name="line.169"></a>
<span class="sourceLineNo">170</span>    nSentences += 1;<a name="line.170"></a>
<span class="sourceLineNo">171</span><a name="line.171"></a>
<span class="sourceLineNo">172</span>    if (sentence.getCoveredText().length() &gt; 40)<a name="line.172"></a>
<span class="sourceLineNo">173</span>      logger.fine(String.format(<a name="line.173"></a>
<span class="sourceLineNo">174</span>          "process sentence \"%s ...\"",<a name="line.174"></a>
<span class="sourceLineNo">175</span>          sentence.getCoveredText().substring(0, 39)));<a name="line.175"></a>
<span class="sourceLineNo">176</span>    else<a name="line.176"></a>
<span class="sourceLineNo">177</span>      logger.fine(String.format("process sentence \"%s\"", sentence.getCoveredText()));<a name="line.177"></a>
<span class="sourceLineNo">178</span><a name="line.178"></a>
<span class="sourceLineNo">179</span>    /*<a name="line.179"></a>
<span class="sourceLineNo">180</span>     * Pre-compute sentence level data: sentenceConstituents: list of all constituents in sentence<a name="line.180"></a>
<span class="sourceLineNo">181</span>     */<a name="line.181"></a>
<span class="sourceLineNo">182</span>    TopTreebankNode top = AnnotationUtil.selectFirstMatching(jCas, TopTreebankNode.class, sentence);<a name="line.182"></a>
<span class="sourceLineNo">183</span>    if (top == null) {<a name="line.183"></a>
<span class="sourceLineNo">184</span>      CleartkExtractorException.noAnnotationInWindow(TopTreebankNode.class, sentence);<a name="line.184"></a>
<span class="sourceLineNo">185</span>    }<a name="line.185"></a>
<span class="sourceLineNo">186</span>    List&lt;TreebankNode&gt; sentenceConstituents = new ArrayList&lt;TreebankNode&gt;(200);<a name="line.186"></a>
<span class="sourceLineNo">187</span>    collectConstituents(top, sentenceConstituents);<a name="line.187"></a>
<span class="sourceLineNo">188</span><a name="line.188"></a>
<span class="sourceLineNo">189</span>    /*<a name="line.189"></a>
<span class="sourceLineNo">190</span>     * Compute constituent features for all constituents in sentence<a name="line.190"></a>
<span class="sourceLineNo">191</span>     */<a name="line.191"></a>
<span class="sourceLineNo">192</span>    List&lt;List&lt;Feature&gt;&gt; sentenceConstituentFeatures = new ArrayList&lt;List&lt;Feature&gt;&gt;(<a name="line.192"></a>
<span class="sourceLineNo">193</span>        sentenceConstituents.size());<a name="line.193"></a>
<span class="sourceLineNo">194</span>    for (TreebankNode constituent : sentenceConstituents) {<a name="line.194"></a>
<span class="sourceLineNo">195</span>      sentenceConstituentFeatures.add(perConstituentExtractor.extract(jCas, constituent));<a name="line.195"></a>
<span class="sourceLineNo">196</span>    }<a name="line.196"></a>
<span class="sourceLineNo">197</span><a name="line.197"></a>
<span class="sourceLineNo">198</span>    /*<a name="line.198"></a>
<span class="sourceLineNo">199</span>     * Iterate over predicates in sentence<a name="line.199"></a>
<span class="sourceLineNo">200</span>     */<a name="line.200"></a>
<span class="sourceLineNo">201</span>    List&lt;Predicate&gt; predicates = JCasUtil.selectCovered(jCas, Predicate.class, sentence);<a name="line.201"></a>
<span class="sourceLineNo">202</span>    for (Predicate predicate : predicates) {<a name="line.202"></a>
<span class="sourceLineNo">203</span>      processPredicate(jCas, predicate, sentenceConstituents, sentenceConstituentFeatures);<a name="line.203"></a>
<span class="sourceLineNo">204</span>    }<a name="line.204"></a>
<span class="sourceLineNo">205</span>  }<a name="line.205"></a>
<span class="sourceLineNo">206</span><a name="line.206"></a>
<span class="sourceLineNo">207</span>  public void processPredicate(<a name="line.207"></a>
<span class="sourceLineNo">208</span>      JCas jCas,<a name="line.208"></a>
<span class="sourceLineNo">209</span>      Predicate predicate,<a name="line.209"></a>
<span class="sourceLineNo">210</span>      List&lt;TreebankNode&gt; sentenceConstituents,<a name="line.210"></a>
<span class="sourceLineNo">211</span>      List&lt;List&lt;Feature&gt;&gt; sentenceConstituentFeatures) throws AnalysisEngineProcessException {<a name="line.211"></a>
<span class="sourceLineNo">212</span>    nPredicates += 1;<a name="line.212"></a>
<span class="sourceLineNo">213</span><a name="line.213"></a>
<span class="sourceLineNo">214</span>    /*<a name="line.214"></a>
<span class="sourceLineNo">215</span>     * Compute predicate features<a name="line.215"></a>
<span class="sourceLineNo">216</span>     */<a name="line.216"></a>
<span class="sourceLineNo">217</span>    List&lt;Feature&gt; predicateFeatures = new ArrayList&lt;Feature&gt;(12);<a name="line.217"></a>
<span class="sourceLineNo">218</span>    predicateFeatures.addAll(perPredicateExtractor.extract(jCas, predicate.getAnnotation()));<a name="line.218"></a>
<span class="sourceLineNo">219</span><a name="line.219"></a>
<span class="sourceLineNo">220</span>    /*<a name="line.220"></a>
<span class="sourceLineNo">221</span>     * Iterate over constituents in sentence<a name="line.221"></a>
<span class="sourceLineNo">222</span>     */<a name="line.222"></a>
<span class="sourceLineNo">223</span>    for (int i = 0; i &lt; sentenceConstituents.size(); i++) {<a name="line.223"></a>
<span class="sourceLineNo">224</span>      nConstituents += 1;<a name="line.224"></a>
<span class="sourceLineNo">225</span>      TreebankNode constituent = sentenceConstituents.get(i);<a name="line.225"></a>
<span class="sourceLineNo">226</span><a name="line.226"></a>
<span class="sourceLineNo">227</span>      Instance&lt;Boolean&gt; instance = new Instance&lt;Boolean&gt;();<a name="line.227"></a>
<span class="sourceLineNo">228</span><a name="line.228"></a>
<span class="sourceLineNo">229</span>      /*<a name="line.229"></a>
<span class="sourceLineNo">230</span>       * Compute predicate-constituent features<a name="line.230"></a>
<span class="sourceLineNo">231</span>       */<a name="line.231"></a>
<span class="sourceLineNo">232</span>      instance.addAll(perPredicatAndConstituentExtractor.extract(<a name="line.232"></a>
<span class="sourceLineNo">233</span>          jCas,<a name="line.233"></a>
<span class="sourceLineNo">234</span>          constituent,<a name="line.234"></a>
<span class="sourceLineNo">235</span>          predicate.getAnnotation()));<a name="line.235"></a>
<span class="sourceLineNo">236</span><a name="line.236"></a>
<span class="sourceLineNo">237</span>      /*<a name="line.237"></a>
<span class="sourceLineNo">238</span>       * Add constituent features<a name="line.238"></a>
<span class="sourceLineNo">239</span>       */<a name="line.239"></a>
<span class="sourceLineNo">240</span>      instance.addAll(sentenceConstituentFeatures.get(i));<a name="line.240"></a>
<span class="sourceLineNo">241</span><a name="line.241"></a>
<span class="sourceLineNo">242</span>      /*<a name="line.242"></a>
<span class="sourceLineNo">243</span>       * Add predicate features<a name="line.243"></a>
<span class="sourceLineNo">244</span>       */<a name="line.244"></a>
<span class="sourceLineNo">245</span>      instance.addAll(predicateFeatures);<a name="line.245"></a>
<span class="sourceLineNo">246</span><a name="line.246"></a>
<span class="sourceLineNo">247</span>      if (isTraining()) {<a name="line.247"></a>
<span class="sourceLineNo">248</span>        instance.setOutcome(false);<a name="line.248"></a>
<span class="sourceLineNo">249</span><a name="line.249"></a>
<span class="sourceLineNo">250</span>        for (int j = 0; j &lt; predicate.getArguments().size(); j++) {<a name="line.250"></a>
<span class="sourceLineNo">251</span>          Argument arg = predicate.getArguments(j);<a name="line.251"></a>
<span class="sourceLineNo">252</span>          if (arg.getAnnotation().equals(constituent)) {<a name="line.252"></a>
<span class="sourceLineNo">253</span>            instance.setOutcome(true);<a name="line.253"></a>
<span class="sourceLineNo">254</span>            break;<a name="line.254"></a>
<span class="sourceLineNo">255</span>          }<a name="line.255"></a>
<span class="sourceLineNo">256</span>        }<a name="line.256"></a>
<span class="sourceLineNo">257</span>      }<a name="line.257"></a>
<span class="sourceLineNo">258</span><a name="line.258"></a>
<span class="sourceLineNo">259</span>      if (this.isTraining()) {<a name="line.259"></a>
<span class="sourceLineNo">260</span>        this.dataWriter.write(instance);<a name="line.260"></a>
<span class="sourceLineNo">261</span>      } else {<a name="line.261"></a>
<span class="sourceLineNo">262</span>        boolean isArgument = this.classifier.classify(instance.getFeatures());<a name="line.262"></a>
<span class="sourceLineNo">263</span><a name="line.263"></a>
<span class="sourceLineNo">264</span>        if (isArgument) {<a name="line.264"></a>
<span class="sourceLineNo">265</span>          SemanticArgument arg = new SemanticArgument(jCas);<a name="line.265"></a>
<span class="sourceLineNo">266</span>          arg.setAnnotation(constituent);<a name="line.266"></a>
<span class="sourceLineNo">267</span>          arg.setBegin(constituent.getBegin());<a name="line.267"></a>
<span class="sourceLineNo">268</span>          arg.setEnd(constituent.getEnd());<a name="line.268"></a>
<span class="sourceLineNo">269</span>          arg.setLabel("?");<a name="line.269"></a>
<span class="sourceLineNo">270</span>          arg.addToIndexes();<a name="line.270"></a>
<span class="sourceLineNo">271</span><a name="line.271"></a>
<span class="sourceLineNo">272</span>          List&lt;Argument&gt; args = UIMAUtil.toList(predicate.getArguments(), Argument.class);<a name="line.272"></a>
<span class="sourceLineNo">273</span>          args.add(arg);<a name="line.273"></a>
<span class="sourceLineNo">274</span>          predicate.setArguments(UIMAUtil.toFSArray(jCas, args));<a name="line.274"></a>
<span class="sourceLineNo">275</span>        }<a name="line.275"></a>
<span class="sourceLineNo">276</span>      }<a name="line.276"></a>
<span class="sourceLineNo">277</span><a name="line.277"></a>
<span class="sourceLineNo">278</span>    }<a name="line.278"></a>
<span class="sourceLineNo">279</span>  }<a name="line.279"></a>
<span class="sourceLineNo">280</span><a name="line.280"></a>
<span class="sourceLineNo">281</span>  /**<a name="line.281"></a>
<span class="sourceLineNo">282</span>   * Recursively build a list of constituents under a TreebankNode.<a name="line.282"></a>
<span class="sourceLineNo">283</span>   * <a name="line.283"></a>
<span class="sourceLineNo">284</span>   * @param top<a name="line.284"></a>
<span class="sourceLineNo">285</span>   *          the root of the parse tree to operate on; &lt;b&gt;top&lt;/b&gt; itself will also be added, unless<a name="line.285"></a>
<span class="sourceLineNo">286</span>   *          it is of type TopTrebankNode<a name="line.286"></a>
<span class="sourceLineNo">287</span>   * @param constituents<a name="line.287"></a>
<span class="sourceLineNo">288</span>   *          list of nodes to add to<a name="line.288"></a>
<span class="sourceLineNo">289</span>   */<a name="line.289"></a>
<span class="sourceLineNo">290</span>  protected void collectConstituents(TreebankNode top, List&lt;TreebankNode&gt; constituents) {<a name="line.290"></a>
<span class="sourceLineNo">291</span>    if (!(top instanceof TopTreebankNode))<a name="line.291"></a>
<span class="sourceLineNo">292</span>      constituents.add(top);<a name="line.292"></a>
<span class="sourceLineNo">293</span><a name="line.293"></a>
<span class="sourceLineNo">294</span>    if (top.getChildren() == null)<a name="line.294"></a>
<span class="sourceLineNo">295</span>      return;<a name="line.295"></a>
<span class="sourceLineNo">296</span><a name="line.296"></a>
<span class="sourceLineNo">297</span>    int numberOfChildren = top.getChildren().size();<a name="line.297"></a>
<span class="sourceLineNo">298</span>    for (int i = 0; i &lt; numberOfChildren; i++) {<a name="line.298"></a>
<span class="sourceLineNo">299</span>      collectConstituents(top.getChildren(i), constituents);<a name="line.299"></a>
<span class="sourceLineNo">300</span>    }<a name="line.300"></a>
<span class="sourceLineNo">301</span>  }<a name="line.301"></a>
<span class="sourceLineNo">302</span><a name="line.302"></a>
<span class="sourceLineNo">303</span>  private SimpleFeatureExtractor perPredicateExtractor;<a name="line.303"></a>
<span class="sourceLineNo">304</span><a name="line.304"></a>
<span class="sourceLineNo">305</span>  private SimpleFeatureExtractor perConstituentExtractor;<a name="line.305"></a>
<span class="sourceLineNo">306</span><a name="line.306"></a>
<span class="sourceLineNo">307</span>  private AnnotationPairFeatureExtractor perPredicatAndConstituentExtractor;<a name="line.307"></a>
<span class="sourceLineNo">308</span><a name="line.308"></a>
<span class="sourceLineNo">309</span>  private int nSentences;<a name="line.309"></a>
<span class="sourceLineNo">310</span><a name="line.310"></a>
<span class="sourceLineNo">311</span>  private int nPredicates;<a name="line.311"></a>
<span class="sourceLineNo">312</span><a name="line.312"></a>
<span class="sourceLineNo">313</span>  private int nConstituents;<a name="line.313"></a>
<span class="sourceLineNo">314</span><a name="line.314"></a>
<span class="sourceLineNo">315</span>  private Logger logger = Logger.getLogger(this.getClass().getName());<a name="line.315"></a>
<span class="sourceLineNo">316</span><a name="line.316"></a>
<span class="sourceLineNo">317</span>}<a name="line.317"></a>




























































</pre>
</div>
</body>
</html>
