<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
<title>Source code</title>
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
</head>
<body>
<div class="sourceContainer">
<pre><span class="sourceLineNo">001</span>/** <a name="line.1"></a>
<span class="sourceLineNo">002</span> * Copyright (c) 2007-2008, Regents of the University of Colorado <a name="line.2"></a>
<span class="sourceLineNo">003</span> * All rights reserved.<a name="line.3"></a>
<span class="sourceLineNo">004</span> * <a name="line.4"></a>
<span class="sourceLineNo">005</span> * Redistribution and use in source and binary forms, with or without<a name="line.5"></a>
<span class="sourceLineNo">006</span> * modification, are permitted provided that the following conditions are met:<a name="line.6"></a>
<span class="sourceLineNo">007</span> * <a name="line.7"></a>
<span class="sourceLineNo">008</span> * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. <a name="line.8"></a>
<span class="sourceLineNo">009</span> * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. <a name="line.9"></a>
<span class="sourceLineNo">010</span> * Neither the name of the University of Colorado at Boulder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. <a name="line.10"></a>
<span class="sourceLineNo">011</span> * <a name="line.11"></a>
<span class="sourceLineNo">012</span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"<a name="line.12"></a>
<span class="sourceLineNo">013</span> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE<a name="line.13"></a>
<span class="sourceLineNo">014</span> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<a name="line.14"></a>
<span class="sourceLineNo">015</span> * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE<a name="line.15"></a>
<span class="sourceLineNo">016</span> * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR<a name="line.16"></a>
<span class="sourceLineNo">017</span> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF<a name="line.17"></a>
<span class="sourceLineNo">018</span> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS<a name="line.18"></a>
<span class="sourceLineNo">019</span> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN<a name="line.19"></a>
<span class="sourceLineNo">020</span> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)<a name="line.20"></a>
<span class="sourceLineNo">021</span> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE<a name="line.21"></a>
<span class="sourceLineNo">022</span> * POSSIBILITY OF SUCH DAMAGE. <a name="line.22"></a>
<span class="sourceLineNo">023</span> */<a name="line.23"></a>
<span class="sourceLineNo">024</span>package org.cleartk.classifier.viterbi;<a name="line.24"></a>
<span class="sourceLineNo">025</span><a name="line.25"></a>
<span class="sourceLineNo">026</span>import java.lang.reflect.Type;<a name="line.26"></a>
<span class="sourceLineNo">027</span>import java.util.ArrayList;<a name="line.27"></a>
<span class="sourceLineNo">028</span>import java.util.Collections;<a name="line.28"></a>
<span class="sourceLineNo">029</span>import java.util.HashMap;<a name="line.29"></a>
<span class="sourceLineNo">030</span>import java.util.List;<a name="line.30"></a>
<span class="sourceLineNo">031</span>import java.util.Map;<a name="line.31"></a>
<span class="sourceLineNo">032</span><a name="line.32"></a>
<span class="sourceLineNo">033</span>import org.apache.uima.UimaContext;<a name="line.33"></a>
<span class="sourceLineNo">034</span>import org.apache.uima.resource.ResourceInitializationException;<a name="line.34"></a>
<span class="sourceLineNo">035</span>import org.cleartk.classifier.Classifier;<a name="line.35"></a>
<span class="sourceLineNo">036</span>import org.cleartk.classifier.CleartkProcessingException;<a name="line.36"></a>
<span class="sourceLineNo">037</span>import org.cleartk.classifier.Feature;<a name="line.37"></a>
<span class="sourceLineNo">038</span>import org.cleartk.classifier.ScoredOutcome;<a name="line.38"></a>
<span class="sourceLineNo">039</span>import org.cleartk.classifier.SequenceClassifier;<a name="line.39"></a>
<span class="sourceLineNo">040</span>import org.cleartk.util.CleartkInitializationException;<a name="line.40"></a>
<span class="sourceLineNo">041</span>import org.cleartk.util.ReflectionUtil;<a name="line.41"></a>
<span class="sourceLineNo">042</span>import org.cleartk.util.ReflectionUtil.TypeArgumentDelegator;<a name="line.42"></a>
<span class="sourceLineNo">043</span>import org.uimafit.component.initialize.ConfigurationParameterInitializer;<a name="line.43"></a>
<span class="sourceLineNo">044</span>import org.uimafit.descriptor.ConfigurationParameter;<a name="line.44"></a>
<span class="sourceLineNo">045</span>import org.uimafit.factory.ConfigurationParameterFactory;<a name="line.45"></a>
<span class="sourceLineNo">046</span>import org.uimafit.factory.initializable.Initializable;<a name="line.46"></a>
<span class="sourceLineNo">047</span><a name="line.47"></a>
<span class="sourceLineNo">048</span>/**<a name="line.48"></a>
<span class="sourceLineNo">049</span> * &lt;br&gt;<a name="line.49"></a>
<span class="sourceLineNo">050</span> * Copyright (c) 2007-2008, Regents of the University of Colorado &lt;br&gt;<a name="line.50"></a>
<span class="sourceLineNo">051</span> * All rights reserved.<a name="line.51"></a>
<span class="sourceLineNo">052</span> */<a name="line.52"></a>
<span class="sourceLineNo">053</span><a name="line.53"></a>
<span class="sourceLineNo">054</span>public class ViterbiClassifier&lt;OUTCOME_TYPE&gt; implements SequenceClassifier&lt;OUTCOME_TYPE&gt;,<a name="line.54"></a>
<span class="sourceLineNo">055</span>    Initializable, TypeArgumentDelegator {<a name="line.55"></a>
<span class="sourceLineNo">056</span><a name="line.56"></a>
<span class="sourceLineNo">057</span>  protected Classifier&lt;OUTCOME_TYPE&gt; delegatedClassifier;<a name="line.57"></a>
<span class="sourceLineNo">058</span><a name="line.58"></a>
<span class="sourceLineNo">059</span>  protected OutcomeFeatureExtractor[] outcomeFeatureExtractors;<a name="line.59"></a>
<span class="sourceLineNo">060</span><a name="line.60"></a>
<span class="sourceLineNo">061</span>  public static final String PARAM_STACK_SIZE = ConfigurationParameterFactory.createConfigurationParameterName(<a name="line.61"></a>
<span class="sourceLineNo">062</span>      ViterbiClassifier.class,<a name="line.62"></a>
<span class="sourceLineNo">063</span>      "stackSize");<a name="line.63"></a>
<span class="sourceLineNo">064</span><a name="line.64"></a>
<span class="sourceLineNo">065</span>  @ConfigurationParameter(<a name="line.65"></a>
<span class="sourceLineNo">066</span>      description = "specifies the maximum number of candidate paths to "<a name="line.66"></a>
<span class="sourceLineNo">067</span>          + "keep track of. In general, this number should be higher than the number "<a name="line.67"></a>
<span class="sourceLineNo">068</span>          + "of possible classifications at any given point in the sequence. This "<a name="line.68"></a>
<span class="sourceLineNo">069</span>          + "guarantees that highest-possible scoring sequence will be returned. If, "<a name="line.69"></a>
<span class="sourceLineNo">070</span>          + "however, the number of possible classifications is quite high and/or you "<a name="line.70"></a>
<span class="sourceLineNo">071</span>          + "are concerned about throughput performance, then you may want to reduce the number "<a name="line.71"></a>
<span class="sourceLineNo">072</span>          + "of candidate paths to maintain.  If Classifier.score is not implemented for the given delegated classifier, then "<a name="line.72"></a>
<span class="sourceLineNo">073</span>          + "the value of this parameter must be 1. ",<a name="line.73"></a>
<span class="sourceLineNo">074</span>      defaultValue = "1")<a name="line.74"></a>
<span class="sourceLineNo">075</span>  protected int stackSize;<a name="line.75"></a>
<span class="sourceLineNo">076</span><a name="line.76"></a>
<span class="sourceLineNo">077</span>  public static final String PARAM_ADD_SCORES = ConfigurationParameterFactory.createConfigurationParameterName(<a name="line.77"></a>
<span class="sourceLineNo">078</span>      ViterbiClassifier.class,<a name="line.78"></a>
<span class="sourceLineNo">079</span>      "addScores");<a name="line.79"></a>
<span class="sourceLineNo">080</span><a name="line.80"></a>
<span class="sourceLineNo">081</span>  @ConfigurationParameter(<a name="line.81"></a>
<span class="sourceLineNo">082</span>      description = "specifies whether the scores of candidate sequence classifications should be "<a name="line.82"></a>
<span class="sourceLineNo">083</span>          + "calculated by summing classfication scores for each member of the sequence or by multiplying them. A value of "<a name="line.83"></a>
<span class="sourceLineNo">084</span>          + "true means that the scores will be summed. A value of false means that the scores will be multiplied. ",<a name="line.84"></a>
<span class="sourceLineNo">085</span>      defaultValue = "false")<a name="line.85"></a>
<span class="sourceLineNo">086</span>  protected boolean addScores = false;<a name="line.86"></a>
<span class="sourceLineNo">087</span><a name="line.87"></a>
<span class="sourceLineNo">088</span>  public ViterbiClassifier(<a name="line.88"></a>
<span class="sourceLineNo">089</span>      Classifier&lt;OUTCOME_TYPE&gt; delegatedClassifier,<a name="line.89"></a>
<span class="sourceLineNo">090</span>      OutcomeFeatureExtractor[] outcomeFeatureExtractors) {<a name="line.90"></a>
<span class="sourceLineNo">091</span>    this.delegatedClassifier = delegatedClassifier;<a name="line.91"></a>
<span class="sourceLineNo">092</span>    this.outcomeFeatureExtractors = outcomeFeatureExtractors;<a name="line.92"></a>
<span class="sourceLineNo">093</span>  }<a name="line.93"></a>
<span class="sourceLineNo">094</span><a name="line.94"></a>
<span class="sourceLineNo">095</span>  public void initialize(UimaContext context) throws ResourceInitializationException {<a name="line.95"></a>
<span class="sourceLineNo">096</span>    ConfigurationParameterInitializer.initialize(this, context);<a name="line.96"></a>
<span class="sourceLineNo">097</span>    if (stackSize &lt; 1) {<a name="line.97"></a>
<span class="sourceLineNo">098</span>      throw CleartkInitializationException.parameterLessThan(PARAM_STACK_SIZE, 1, stackSize);<a name="line.98"></a>
<span class="sourceLineNo">099</span>    }<a name="line.99"></a>
<span class="sourceLineNo">100</span>  }<a name="line.100"></a>
<span class="sourceLineNo">101</span><a name="line.101"></a>
<span class="sourceLineNo">102</span>  public List&lt;OUTCOME_TYPE&gt; classify(List&lt;List&lt;Feature&gt;&gt; features)<a name="line.102"></a>
<span class="sourceLineNo">103</span>      throws CleartkProcessingException {<a name="line.103"></a>
<span class="sourceLineNo">104</span>    if (stackSize == 1) {<a name="line.104"></a>
<span class="sourceLineNo">105</span>      List&lt;Object&gt; outcomes = new ArrayList&lt;Object&gt;();<a name="line.105"></a>
<span class="sourceLineNo">106</span>      List&lt;OUTCOME_TYPE&gt; returnValues = new ArrayList&lt;OUTCOME_TYPE&gt;();<a name="line.106"></a>
<span class="sourceLineNo">107</span>      for (List&lt;Feature&gt; instanceFeatures : features) {<a name="line.107"></a>
<span class="sourceLineNo">108</span>        for (OutcomeFeatureExtractor outcomeFeatureExtractor : outcomeFeatureExtractors) {<a name="line.108"></a>
<span class="sourceLineNo">109</span>          instanceFeatures.addAll(outcomeFeatureExtractor.extractFeatures(outcomes));<a name="line.109"></a>
<span class="sourceLineNo">110</span>        }<a name="line.110"></a>
<span class="sourceLineNo">111</span>        OUTCOME_TYPE outcome = delegatedClassifier.classify(instanceFeatures);<a name="line.111"></a>
<span class="sourceLineNo">112</span>        outcomes.add(outcome);<a name="line.112"></a>
<span class="sourceLineNo">113</span>        returnValues.add(outcome);<a name="line.113"></a>
<span class="sourceLineNo">114</span>      }<a name="line.114"></a>
<span class="sourceLineNo">115</span>      return returnValues;<a name="line.115"></a>
<span class="sourceLineNo">116</span>    } else {<a name="line.116"></a>
<span class="sourceLineNo">117</span>      try {<a name="line.117"></a>
<span class="sourceLineNo">118</span>        return viterbi(features);<a name="line.118"></a>
<span class="sourceLineNo">119</span>      } catch (UnsupportedOperationException uoe) {<a name="line.119"></a>
<span class="sourceLineNo">120</span>        throw CleartkProcessingException.unsupportedOperationSetParameter(<a name="line.120"></a>
<span class="sourceLineNo">121</span>            delegatedClassifier,<a name="line.121"></a>
<span class="sourceLineNo">122</span>            "score",<a name="line.122"></a>
<span class="sourceLineNo">123</span>            PARAM_STACK_SIZE,<a name="line.123"></a>
<span class="sourceLineNo">124</span>            1);<a name="line.124"></a>
<span class="sourceLineNo">125</span>      }<a name="line.125"></a>
<span class="sourceLineNo">126</span>    }<a name="line.126"></a>
<span class="sourceLineNo">127</span><a name="line.127"></a>
<span class="sourceLineNo">128</span>  }<a name="line.128"></a>
<span class="sourceLineNo">129</span><a name="line.129"></a>
<span class="sourceLineNo">130</span>  /**<a name="line.130"></a>
<span class="sourceLineNo">131</span>   * This implementation of Viterbi requires at most stackSize * sequenceLength calls to the<a name="line.131"></a>
<span class="sourceLineNo">132</span>   * classifier. If this proves to be too expensive, then consider using a smaller stack size.<a name="line.132"></a>
<span class="sourceLineNo">133</span>   * <a name="line.133"></a>
<span class="sourceLineNo">134</span>   * @param features<a name="line.134"></a>
<span class="sourceLineNo">135</span>   *          a sequence-worth of features. Each List&lt;Feature&gt; in features should corresond to all<a name="line.135"></a>
<span class="sourceLineNo">136</span>   *          of the features for a given element in a sequence to be classified.<a name="line.136"></a>
<span class="sourceLineNo">137</span>   * @return a list of outcomes (classifications) - one classification for each member of the<a name="line.137"></a>
<span class="sourceLineNo">138</span>   *         sequence.<a name="line.138"></a>
<span class="sourceLineNo">139</span>   * @see #PARAM_STACK_SIZE<a name="line.139"></a>
<span class="sourceLineNo">140</span>   * @see OutcomeFeatureExtractor<a name="line.140"></a>
<span class="sourceLineNo">141</span>   */<a name="line.141"></a>
<span class="sourceLineNo">142</span>  public List&lt;OUTCOME_TYPE&gt; viterbi(List&lt;List&lt;Feature&gt;&gt; features) throws CleartkProcessingException {<a name="line.142"></a>
<span class="sourceLineNo">143</span><a name="line.143"></a>
<span class="sourceLineNo">144</span>    List&lt;ScoredOutcome&lt;List&lt;OUTCOME_TYPE&gt;&gt;&gt; nbestSequences = new ArrayList&lt;ScoredOutcome&lt;List&lt;OUTCOME_TYPE&gt;&gt;&gt;();<a name="line.144"></a>
<span class="sourceLineNo">145</span><a name="line.145"></a>
<span class="sourceLineNo">146</span>    if (features == null || features.size() == 0) {<a name="line.146"></a>
<span class="sourceLineNo">147</span>      return Collections.emptyList();<a name="line.147"></a>
<span class="sourceLineNo">148</span>    }<a name="line.148"></a>
<span class="sourceLineNo">149</span><a name="line.149"></a>
<span class="sourceLineNo">150</span>    List&lt;ScoredOutcome&lt;OUTCOME_TYPE&gt;&gt; scoredOutcomes = delegatedClassifier.score(<a name="line.150"></a>
<span class="sourceLineNo">151</span>        features.get(0),<a name="line.151"></a>
<span class="sourceLineNo">152</span>        stackSize);<a name="line.152"></a>
<span class="sourceLineNo">153</span>    for (ScoredOutcome&lt;OUTCOME_TYPE&gt; scoredOutcome : scoredOutcomes) {<a name="line.153"></a>
<span class="sourceLineNo">154</span>      double score = scoredOutcome.getScore();<a name="line.154"></a>
<span class="sourceLineNo">155</span>      List&lt;OUTCOME_TYPE&gt; sequence = new ArrayList&lt;OUTCOME_TYPE&gt;();<a name="line.155"></a>
<span class="sourceLineNo">156</span>      sequence.add(scoredOutcome.getOutcome());<a name="line.156"></a>
<span class="sourceLineNo">157</span>      nbestSequences.add(new ScoredOutcome&lt;List&lt;OUTCOME_TYPE&gt;&gt;(sequence, score));<a name="line.157"></a>
<span class="sourceLineNo">158</span>    }<a name="line.158"></a>
<span class="sourceLineNo">159</span><a name="line.159"></a>
<span class="sourceLineNo">160</span>    Map&lt;OUTCOME_TYPE, Double&gt; l = new HashMap&lt;OUTCOME_TYPE, Double&gt;();<a name="line.160"></a>
<span class="sourceLineNo">161</span>    Map&lt;OUTCOME_TYPE, List&lt;OUTCOME_TYPE&gt;&gt; m = new HashMap&lt;OUTCOME_TYPE, List&lt;OUTCOME_TYPE&gt;&gt;();<a name="line.161"></a>
<span class="sourceLineNo">162</span><a name="line.162"></a>
<span class="sourceLineNo">163</span>    for (int i = 1; i &lt; features.size(); i++) {<a name="line.163"></a>
<span class="sourceLineNo">164</span><a name="line.164"></a>
<span class="sourceLineNo">165</span>      List&lt;Feature&gt; instanceFeatures = features.get(i);<a name="line.165"></a>
<span class="sourceLineNo">166</span>      l.clear();<a name="line.166"></a>
<span class="sourceLineNo">167</span>      m.clear();<a name="line.167"></a>
<span class="sourceLineNo">168</span>      for (ScoredOutcome&lt;List&lt;OUTCOME_TYPE&gt;&gt; scoredSequence : nbestSequences) {<a name="line.168"></a>
<span class="sourceLineNo">169</span>        // add features from previous outcomes from each scoredSequence<a name="line.169"></a>
<span class="sourceLineNo">170</span>        // in returnValues<a name="line.170"></a>
<span class="sourceLineNo">171</span>        int outcomeFeaturesCount = 0;<a name="line.171"></a>
<span class="sourceLineNo">172</span>        List&lt;Object&gt; previousOutcomes = new ArrayList&lt;Object&gt;(scoredSequence.getOutcome());<a name="line.172"></a>
<span class="sourceLineNo">173</span>        for (OutcomeFeatureExtractor outcomeFeatureExtractor : outcomeFeatureExtractors) {<a name="line.173"></a>
<span class="sourceLineNo">174</span>          List&lt;Feature&gt; outcomeFeatures = outcomeFeatureExtractor.extractFeatures(previousOutcomes);<a name="line.174"></a>
<span class="sourceLineNo">175</span>          instanceFeatures.addAll(outcomeFeatures);<a name="line.175"></a>
<span class="sourceLineNo">176</span>          outcomeFeaturesCount += outcomeFeatures.size();<a name="line.176"></a>
<span class="sourceLineNo">177</span>        }<a name="line.177"></a>
<span class="sourceLineNo">178</span>        // score the instance features using the features added by the<a name="line.178"></a>
<span class="sourceLineNo">179</span>        // outcomeFeatureExtractors<a name="line.179"></a>
<span class="sourceLineNo">180</span>        scoredOutcomes = delegatedClassifier.score(instanceFeatures, stackSize);<a name="line.180"></a>
<span class="sourceLineNo">181</span>        // remove the added features from previous outcomes for this<a name="line.181"></a>
<span class="sourceLineNo">182</span>        // scoredSequence<a name="line.182"></a>
<span class="sourceLineNo">183</span>        instanceFeatures = instanceFeatures.subList(0, instanceFeatures.size()<a name="line.183"></a>
<span class="sourceLineNo">184</span>            - outcomeFeaturesCount);<a name="line.184"></a>
<span class="sourceLineNo">185</span><a name="line.185"></a>
<span class="sourceLineNo">186</span>        for (ScoredOutcome&lt;OUTCOME_TYPE&gt; scoredOutcome : scoredOutcomes) {<a name="line.186"></a>
<span class="sourceLineNo">187</span><a name="line.187"></a>
<span class="sourceLineNo">188</span>          if (!l.containsKey(scoredOutcome.getOutcome())) {<a name="line.188"></a>
<span class="sourceLineNo">189</span>            double score = scoredSequence.getScore();<a name="line.189"></a>
<span class="sourceLineNo">190</span>            if (addScores) {<a name="line.190"></a>
<span class="sourceLineNo">191</span>              score = score + scoredOutcome.getScore();<a name="line.191"></a>
<span class="sourceLineNo">192</span>            } else {<a name="line.192"></a>
<span class="sourceLineNo">193</span>              score = score * scoredOutcome.getScore();<a name="line.193"></a>
<span class="sourceLineNo">194</span>            }<a name="line.194"></a>
<span class="sourceLineNo">195</span>            l.put(scoredOutcome.getOutcome(), score);<a name="line.195"></a>
<span class="sourceLineNo">196</span>            m.put(<a name="line.196"></a>
<span class="sourceLineNo">197</span>                scoredOutcome.getOutcome(),<a name="line.197"></a>
<span class="sourceLineNo">198</span>                new ArrayList&lt;OUTCOME_TYPE&gt;(scoredSequence.getOutcome()));<a name="line.198"></a>
<span class="sourceLineNo">199</span>          } else {<a name="line.199"></a>
<span class="sourceLineNo">200</span>            double newScore = scoredSequence.getScore();<a name="line.200"></a>
<span class="sourceLineNo">201</span>            if (addScores) {<a name="line.201"></a>
<span class="sourceLineNo">202</span>              newScore = newScore + scoredOutcome.getScore();<a name="line.202"></a>
<span class="sourceLineNo">203</span>            } else {<a name="line.203"></a>
<span class="sourceLineNo">204</span>              newScore = newScore * scoredOutcome.getScore();<a name="line.204"></a>
<span class="sourceLineNo">205</span>            }<a name="line.205"></a>
<span class="sourceLineNo">206</span>            double bestScore = l.get(scoredOutcome.getOutcome());<a name="line.206"></a>
<span class="sourceLineNo">207</span><a name="line.207"></a>
<span class="sourceLineNo">208</span>            if (newScore &gt; bestScore) {<a name="line.208"></a>
<span class="sourceLineNo">209</span>              l.put(scoredOutcome.getOutcome(), newScore);<a name="line.209"></a>
<span class="sourceLineNo">210</span>              m.put(<a name="line.210"></a>
<span class="sourceLineNo">211</span>                  scoredOutcome.getOutcome(),<a name="line.211"></a>
<span class="sourceLineNo">212</span>                  new ArrayList&lt;OUTCOME_TYPE&gt;(scoredSequence.getOutcome()));<a name="line.212"></a>
<span class="sourceLineNo">213</span>            }<a name="line.213"></a>
<span class="sourceLineNo">214</span>          }<a name="line.214"></a>
<span class="sourceLineNo">215</span>        }<a name="line.215"></a>
<span class="sourceLineNo">216</span>      }<a name="line.216"></a>
<span class="sourceLineNo">217</span><a name="line.217"></a>
<span class="sourceLineNo">218</span>      nbestSequences.clear();<a name="line.218"></a>
<span class="sourceLineNo">219</span>      for (OUTCOME_TYPE outcome : l.keySet()) {<a name="line.219"></a>
<span class="sourceLineNo">220</span>        List&lt;OUTCOME_TYPE&gt; outcomeSequence = m.get(outcome);<a name="line.220"></a>
<span class="sourceLineNo">221</span>        outcomeSequence.add(outcome);<a name="line.221"></a>
<span class="sourceLineNo">222</span>        double score = l.get(outcome);<a name="line.222"></a>
<span class="sourceLineNo">223</span>        ScoredOutcome&lt;List&lt;OUTCOME_TYPE&gt;&gt; returnValue = new ScoredOutcome&lt;List&lt;OUTCOME_TYPE&gt;&gt;(<a name="line.223"></a>
<span class="sourceLineNo">224</span>            outcomeSequence,<a name="line.224"></a>
<span class="sourceLineNo">225</span>            score);<a name="line.225"></a>
<span class="sourceLineNo">226</span>        nbestSequences.add(returnValue);<a name="line.226"></a>
<span class="sourceLineNo">227</span>      }<a name="line.227"></a>
<span class="sourceLineNo">228</span><a name="line.228"></a>
<span class="sourceLineNo">229</span>      Collections.sort(nbestSequences);<a name="line.229"></a>
<span class="sourceLineNo">230</span>    }<a name="line.230"></a>
<span class="sourceLineNo">231</span><a name="line.231"></a>
<span class="sourceLineNo">232</span>    Collections.sort(nbestSequences);<a name="line.232"></a>
<span class="sourceLineNo">233</span>    if (nbestSequences.size() &gt; 0) {<a name="line.233"></a>
<span class="sourceLineNo">234</span>      return nbestSequences.get(0).getOutcome();<a name="line.234"></a>
<span class="sourceLineNo">235</span>    }<a name="line.235"></a>
<span class="sourceLineNo">236</span><a name="line.236"></a>
<span class="sourceLineNo">237</span>    return null;<a name="line.237"></a>
<span class="sourceLineNo">238</span>  }<a name="line.238"></a>
<span class="sourceLineNo">239</span><a name="line.239"></a>
<span class="sourceLineNo">240</span>  public List&lt;ScoredOutcome&lt;List&lt;OUTCOME_TYPE&gt;&gt;&gt; score(List&lt;List&lt;Feature&gt;&gt; features, int maxResults)<a name="line.240"></a>
<span class="sourceLineNo">241</span>      throws CleartkProcessingException {<a name="line.241"></a>
<span class="sourceLineNo">242</span>    // TODO Auto-generated method stub<a name="line.242"></a>
<span class="sourceLineNo">243</span>    return null;<a name="line.243"></a>
<span class="sourceLineNo">244</span>  }<a name="line.244"></a>
<span class="sourceLineNo">245</span><a name="line.245"></a>
<span class="sourceLineNo">246</span>  public Map&lt;String, Type&gt; getTypeArguments(Class&lt;?&gt; genericType) {<a name="line.246"></a>
<span class="sourceLineNo">247</span>    if (genericType.equals(SequenceClassifier.class)) {<a name="line.247"></a>
<span class="sourceLineNo">248</span>      genericType = Classifier.class;<a name="line.248"></a>
<span class="sourceLineNo">249</span>    }<a name="line.249"></a>
<span class="sourceLineNo">250</span>    return ReflectionUtil.getTypeArguments(genericType, this.delegatedClassifier);<a name="line.250"></a>
<span class="sourceLineNo">251</span>  }<a name="line.251"></a>
<span class="sourceLineNo">252</span><a name="line.252"></a>
<span class="sourceLineNo">253</span>}<a name="line.253"></a>




























































</pre>
</div>
</body>
</html>
