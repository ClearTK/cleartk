<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
<title>Source code</title>
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
</head>
<body>
<div class="sourceContainer">
<pre><span class="sourceLineNo">001</span>/** <a name="line.1"></a>
<span class="sourceLineNo">002</span> * Copyright (c) 2007-2008, Regents of the University of Colorado <a name="line.2"></a>
<span class="sourceLineNo">003</span> * All rights reserved.<a name="line.3"></a>
<span class="sourceLineNo">004</span> * <a name="line.4"></a>
<span class="sourceLineNo">005</span> * Redistribution and use in source and binary forms, with or without<a name="line.5"></a>
<span class="sourceLineNo">006</span> * modification, are permitted provided that the following conditions are met:<a name="line.6"></a>
<span class="sourceLineNo">007</span> * <a name="line.7"></a>
<span class="sourceLineNo">008</span> * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. <a name="line.8"></a>
<span class="sourceLineNo">009</span> * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. <a name="line.9"></a>
<span class="sourceLineNo">010</span> * Neither the name of the University of Colorado at Boulder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. <a name="line.10"></a>
<span class="sourceLineNo">011</span> * <a name="line.11"></a>
<span class="sourceLineNo">012</span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"<a name="line.12"></a>
<span class="sourceLineNo">013</span> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE<a name="line.13"></a>
<span class="sourceLineNo">014</span> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<a name="line.14"></a>
<span class="sourceLineNo">015</span> * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE<a name="line.15"></a>
<span class="sourceLineNo">016</span> * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR<a name="line.16"></a>
<span class="sourceLineNo">017</span> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF<a name="line.17"></a>
<span class="sourceLineNo">018</span> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS<a name="line.18"></a>
<span class="sourceLineNo">019</span> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN<a name="line.19"></a>
<span class="sourceLineNo">020</span> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)<a name="line.20"></a>
<span class="sourceLineNo">021</span> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE<a name="line.21"></a>
<span class="sourceLineNo">022</span> * POSSIBILITY OF SUCH DAMAGE. <a name="line.22"></a>
<span class="sourceLineNo">023</span> */<a name="line.23"></a>
<span class="sourceLineNo">024</span>package org.cleartk.ml.viterbi;<a name="line.24"></a>
<span class="sourceLineNo">025</span><a name="line.25"></a>
<span class="sourceLineNo">026</span>import java.lang.reflect.Type;<a name="line.26"></a>
<span class="sourceLineNo">027</span>import java.util.ArrayList;<a name="line.27"></a>
<span class="sourceLineNo">028</span>import java.util.Collection;<a name="line.28"></a>
<span class="sourceLineNo">029</span>import java.util.Collections;<a name="line.29"></a>
<span class="sourceLineNo">030</span>import java.util.List;<a name="line.30"></a>
<span class="sourceLineNo">031</span>import java.util.Map;<a name="line.31"></a>
<span class="sourceLineNo">032</span><a name="line.32"></a>
<span class="sourceLineNo">033</span>import org.apache.uima.UimaContext;<a name="line.33"></a>
<span class="sourceLineNo">034</span>import org.apache.uima.fit.component.initialize.ConfigurationParameterInitializer;<a name="line.34"></a>
<span class="sourceLineNo">035</span>import org.apache.uima.fit.descriptor.ConfigurationParameter;<a name="line.35"></a>
<span class="sourceLineNo">036</span>import org.apache.uima.fit.factory.initializable.Initializable;<a name="line.36"></a>
<span class="sourceLineNo">037</span>import org.apache.uima.resource.ResourceInitializationException;<a name="line.37"></a>
<span class="sourceLineNo">038</span>import org.cleartk.ml.Classifier;<a name="line.38"></a>
<span class="sourceLineNo">039</span>import org.cleartk.ml.CleartkProcessingException;<a name="line.39"></a>
<span class="sourceLineNo">040</span>import org.cleartk.ml.Feature;<a name="line.40"></a>
<span class="sourceLineNo">041</span>import org.cleartk.ml.SequenceClassifier;<a name="line.41"></a>
<span class="sourceLineNo">042</span>import org.cleartk.util.CleartkInitializationException;<a name="line.42"></a>
<span class="sourceLineNo">043</span>import org.cleartk.util.ReflectionUtil;<a name="line.43"></a>
<span class="sourceLineNo">044</span>import org.cleartk.util.ReflectionUtil.TypeArgumentDelegator;<a name="line.44"></a>
<span class="sourceLineNo">045</span><a name="line.45"></a>
<span class="sourceLineNo">046</span>import com.google.common.base.Functions;<a name="line.46"></a>
<span class="sourceLineNo">047</span>import com.google.common.base.Objects;<a name="line.47"></a>
<span class="sourceLineNo">048</span>import com.google.common.base.Objects.ToStringHelper;<a name="line.48"></a>
<span class="sourceLineNo">049</span>import com.google.common.collect.Lists;<a name="line.49"></a>
<span class="sourceLineNo">050</span>import com.google.common.collect.Maps;<a name="line.50"></a>
<span class="sourceLineNo">051</span>import com.google.common.collect.Ordering;<a name="line.51"></a>
<span class="sourceLineNo">052</span>import com.google.common.primitives.Doubles;<a name="line.52"></a>
<span class="sourceLineNo">053</span><a name="line.53"></a>
<span class="sourceLineNo">054</span>/**<a name="line.54"></a>
<span class="sourceLineNo">055</span> * &lt;br&gt;<a name="line.55"></a>
<span class="sourceLineNo">056</span> * Copyright (c) 2007-2008, Regents of the University of Colorado &lt;br&gt;<a name="line.56"></a>
<span class="sourceLineNo">057</span> * All rights reserved.<a name="line.57"></a>
<span class="sourceLineNo">058</span> */<a name="line.58"></a>
<span class="sourceLineNo">059</span><a name="line.59"></a>
<span class="sourceLineNo">060</span>public class ViterbiClassifier&lt;OUTCOME_TYPE&gt; implements SequenceClassifier&lt;OUTCOME_TYPE&gt;,<a name="line.60"></a>
<span class="sourceLineNo">061</span>    Initializable, TypeArgumentDelegator {<a name="line.61"></a>
<span class="sourceLineNo">062</span><a name="line.62"></a>
<span class="sourceLineNo">063</span>  protected Classifier&lt;OUTCOME_TYPE&gt; delegatedClassifier;<a name="line.63"></a>
<span class="sourceLineNo">064</span><a name="line.64"></a>
<span class="sourceLineNo">065</span>  protected OutcomeFeatureExtractor[] outcomeFeatureExtractors;<a name="line.65"></a>
<span class="sourceLineNo">066</span><a name="line.66"></a>
<span class="sourceLineNo">067</span>  public static final String PARAM_STACK_SIZE = "stackSize";<a name="line.67"></a>
<span class="sourceLineNo">068</span><a name="line.68"></a>
<span class="sourceLineNo">069</span>  @ConfigurationParameter(<a name="line.69"></a>
<span class="sourceLineNo">070</span>      name = PARAM_STACK_SIZE,<a name="line.70"></a>
<span class="sourceLineNo">071</span>      description = "specifies the maximum number of candidate paths to "<a name="line.71"></a>
<span class="sourceLineNo">072</span>          + "keep track of. In general, this number should be higher than the number "<a name="line.72"></a>
<span class="sourceLineNo">073</span>          + "of possible classifications at any given point in the sequence. This "<a name="line.73"></a>
<span class="sourceLineNo">074</span>          + "guarantees that highest-possible scoring sequence will be returned. If, "<a name="line.74"></a>
<span class="sourceLineNo">075</span>          + "however, the number of possible classifications is quite high and/or you "<a name="line.75"></a>
<span class="sourceLineNo">076</span>          + "are concerned about throughput performance, then you may want to reduce the number "<a name="line.76"></a>
<span class="sourceLineNo">077</span>          + "of candidate paths to maintain.  If Classifier.score is not implemented for the given delegated classifier, then "<a name="line.77"></a>
<span class="sourceLineNo">078</span>          + "the value of this parameter must be 1. ",<a name="line.78"></a>
<span class="sourceLineNo">079</span>      defaultValue = "1")<a name="line.79"></a>
<span class="sourceLineNo">080</span>  protected int stackSize;<a name="line.80"></a>
<span class="sourceLineNo">081</span><a name="line.81"></a>
<span class="sourceLineNo">082</span>  public static final String PARAM_ADD_SCORES = "addScores";<a name="line.82"></a>
<span class="sourceLineNo">083</span><a name="line.83"></a>
<span class="sourceLineNo">084</span>  @ConfigurationParameter(<a name="line.84"></a>
<span class="sourceLineNo">085</span>      name = PARAM_ADD_SCORES,<a name="line.85"></a>
<span class="sourceLineNo">086</span>      description = "specifies whether the scores of candidate sequence classifications should be "<a name="line.86"></a>
<span class="sourceLineNo">087</span>          + "calculated by summing classfication scores for each member of the sequence or by multiplying them. A value of "<a name="line.87"></a>
<span class="sourceLineNo">088</span>          + "true means that the scores will be summed. A value of false means that the scores will be multiplied. ",<a name="line.88"></a>
<span class="sourceLineNo">089</span>      defaultValue = "false")<a name="line.89"></a>
<span class="sourceLineNo">090</span>  protected boolean addScores = false;<a name="line.90"></a>
<span class="sourceLineNo">091</span><a name="line.91"></a>
<span class="sourceLineNo">092</span>  public ViterbiClassifier(<a name="line.92"></a>
<span class="sourceLineNo">093</span>      Classifier&lt;OUTCOME_TYPE&gt; delegatedClassifier,<a name="line.93"></a>
<span class="sourceLineNo">094</span>      OutcomeFeatureExtractor[] outcomeFeatureExtractors) {<a name="line.94"></a>
<span class="sourceLineNo">095</span>    this.delegatedClassifier = delegatedClassifier;<a name="line.95"></a>
<span class="sourceLineNo">096</span>    this.outcomeFeatureExtractors = outcomeFeatureExtractors;<a name="line.96"></a>
<span class="sourceLineNo">097</span>  }<a name="line.97"></a>
<span class="sourceLineNo">098</span><a name="line.98"></a>
<span class="sourceLineNo">099</span>  public void initialize(UimaContext context) throws ResourceInitializationException {<a name="line.99"></a>
<span class="sourceLineNo">100</span>    ConfigurationParameterInitializer.initialize(this, context);<a name="line.100"></a>
<span class="sourceLineNo">101</span>    if (stackSize &lt; 1) {<a name="line.101"></a>
<span class="sourceLineNo">102</span>      throw CleartkInitializationException.parameterLessThan(PARAM_STACK_SIZE, 1, stackSize);<a name="line.102"></a>
<span class="sourceLineNo">103</span>    }<a name="line.103"></a>
<span class="sourceLineNo">104</span>  }<a name="line.104"></a>
<span class="sourceLineNo">105</span><a name="line.105"></a>
<span class="sourceLineNo">106</span>  public List&lt;OUTCOME_TYPE&gt; classify(List&lt;List&lt;Feature&gt;&gt; features)<a name="line.106"></a>
<span class="sourceLineNo">107</span>      throws CleartkProcessingException {<a name="line.107"></a>
<span class="sourceLineNo">108</span>    if (stackSize == 1) {<a name="line.108"></a>
<span class="sourceLineNo">109</span>      List&lt;Object&gt; outcomes = new ArrayList&lt;Object&gt;();<a name="line.109"></a>
<span class="sourceLineNo">110</span>      List&lt;OUTCOME_TYPE&gt; returnValues = new ArrayList&lt;OUTCOME_TYPE&gt;();<a name="line.110"></a>
<span class="sourceLineNo">111</span>      for (List&lt;Feature&gt; instanceFeatures : features) {<a name="line.111"></a>
<span class="sourceLineNo">112</span>        for (OutcomeFeatureExtractor outcomeFeatureExtractor : outcomeFeatureExtractors) {<a name="line.112"></a>
<span class="sourceLineNo">113</span>          instanceFeatures.addAll(outcomeFeatureExtractor.extractFeatures(outcomes));<a name="line.113"></a>
<span class="sourceLineNo">114</span>        }<a name="line.114"></a>
<span class="sourceLineNo">115</span>        OUTCOME_TYPE outcome = delegatedClassifier.classify(instanceFeatures);<a name="line.115"></a>
<span class="sourceLineNo">116</span>        outcomes.add(outcome);<a name="line.116"></a>
<span class="sourceLineNo">117</span>        returnValues.add(outcome);<a name="line.117"></a>
<span class="sourceLineNo">118</span>      }<a name="line.118"></a>
<span class="sourceLineNo">119</span>      return returnValues;<a name="line.119"></a>
<span class="sourceLineNo">120</span>    } else {<a name="line.120"></a>
<span class="sourceLineNo">121</span>      try {<a name="line.121"></a>
<span class="sourceLineNo">122</span>        return viterbi(features);<a name="line.122"></a>
<span class="sourceLineNo">123</span>      } catch (UnsupportedOperationException uoe) {<a name="line.123"></a>
<span class="sourceLineNo">124</span>        throw CleartkProcessingException.unsupportedOperationSetParameter(<a name="line.124"></a>
<span class="sourceLineNo">125</span>            uoe,<a name="line.125"></a>
<span class="sourceLineNo">126</span>            delegatedClassifier,<a name="line.126"></a>
<span class="sourceLineNo">127</span>            "score",<a name="line.127"></a>
<span class="sourceLineNo">128</span>            PARAM_STACK_SIZE,<a name="line.128"></a>
<span class="sourceLineNo">129</span>            1);<a name="line.129"></a>
<span class="sourceLineNo">130</span>      }<a name="line.130"></a>
<span class="sourceLineNo">131</span>    }<a name="line.131"></a>
<span class="sourceLineNo">132</span><a name="line.132"></a>
<span class="sourceLineNo">133</span>  }<a name="line.133"></a>
<span class="sourceLineNo">134</span><a name="line.134"></a>
<span class="sourceLineNo">135</span>  /**<a name="line.135"></a>
<span class="sourceLineNo">136</span>   * This implementation of Viterbi requires at most stackSize * sequenceLength calls to the<a name="line.136"></a>
<span class="sourceLineNo">137</span>   * classifier. If this proves to be too expensive, then consider using a smaller stack size.<a name="line.137"></a>
<span class="sourceLineNo">138</span>   * <a name="line.138"></a>
<span class="sourceLineNo">139</span>   * @param featureLists<a name="line.139"></a>
<span class="sourceLineNo">140</span>   *          a sequence-worth of features. Each List&lt;Feature&gt; in features should corresond to all<a name="line.140"></a>
<span class="sourceLineNo">141</span>   *          of the features for a given element in a sequence to be classified.<a name="line.141"></a>
<span class="sourceLineNo">142</span>   * @return a list of outcomes (classifications) - one classification for each member of the<a name="line.142"></a>
<span class="sourceLineNo">143</span>   *         sequence.<a name="line.143"></a>
<span class="sourceLineNo">144</span>   * @see #PARAM_STACK_SIZE<a name="line.144"></a>
<span class="sourceLineNo">145</span>   * @see OutcomeFeatureExtractor<a name="line.145"></a>
<span class="sourceLineNo">146</span>   */<a name="line.146"></a>
<span class="sourceLineNo">147</span>  public List&lt;OUTCOME_TYPE&gt; viterbi(List&lt;List&lt;Feature&gt;&gt; featureLists)<a name="line.147"></a>
<span class="sourceLineNo">148</span>      throws CleartkProcessingException {<a name="line.148"></a>
<span class="sourceLineNo">149</span><a name="line.149"></a>
<span class="sourceLineNo">150</span>    if (featureLists == null || featureLists.size() == 0) {<a name="line.150"></a>
<span class="sourceLineNo">151</span>      return Collections.emptyList();<a name="line.151"></a>
<span class="sourceLineNo">152</span>    }<a name="line.152"></a>
<span class="sourceLineNo">153</span><a name="line.153"></a>
<span class="sourceLineNo">154</span>    // find the best paths through the outcome lattice<a name="line.154"></a>
<span class="sourceLineNo">155</span>    Collection&lt;Path&gt; paths = null;<a name="line.155"></a>
<span class="sourceLineNo">156</span>    for (List&lt;Feature&gt; features : featureLists) {<a name="line.156"></a>
<span class="sourceLineNo">157</span><a name="line.157"></a>
<span class="sourceLineNo">158</span>      // if this is the first instance, start new paths for each outcome<a name="line.158"></a>
<span class="sourceLineNo">159</span>      if (paths == null) {<a name="line.159"></a>
<span class="sourceLineNo">160</span>        paths = Lists.newArrayList();<a name="line.160"></a>
<span class="sourceLineNo">161</span>        Map&lt;OUTCOME_TYPE, Double&gt; scoredOutcomes = this.getScoredOutcomes(features, null);<a name="line.161"></a>
<span class="sourceLineNo">162</span>        for (OUTCOME_TYPE outcome : this.getTopOutcomes(scoredOutcomes)) {<a name="line.162"></a>
<span class="sourceLineNo">163</span>          paths.add(new Path(outcome, scoredOutcomes.get(outcome), null));<a name="line.163"></a>
<span class="sourceLineNo">164</span>        }<a name="line.164"></a>
<span class="sourceLineNo">165</span>      }<a name="line.165"></a>
<span class="sourceLineNo">166</span><a name="line.166"></a>
<span class="sourceLineNo">167</span>      // for later instances, find the best previous path for each outcome<a name="line.167"></a>
<span class="sourceLineNo">168</span>      else {<a name="line.168"></a>
<span class="sourceLineNo">169</span>        Map&lt;OUTCOME_TYPE, Path&gt; maxPaths = Maps.newHashMap();<a name="line.169"></a>
<span class="sourceLineNo">170</span>        for (Path path : paths) {<a name="line.170"></a>
<span class="sourceLineNo">171</span>          Map&lt;OUTCOME_TYPE, Double&gt; scoredOutcomes = this.getScoredOutcomes(features, path);<a name="line.171"></a>
<span class="sourceLineNo">172</span>          for (OUTCOME_TYPE outcome : this.getTopOutcomes(scoredOutcomes)) {<a name="line.172"></a>
<span class="sourceLineNo">173</span>            double outcomeScore = scoredOutcomes.get(outcome);<a name="line.173"></a>
<span class="sourceLineNo">174</span>            double score = this.addScores ? path.score + outcomeScore : path.score * outcomeScore;<a name="line.174"></a>
<span class="sourceLineNo">175</span>            Path maxPath = maxPaths.get(outcome);<a name="line.175"></a>
<span class="sourceLineNo">176</span>            if (maxPath == null || score &gt; maxPath.score) {<a name="line.176"></a>
<span class="sourceLineNo">177</span>              maxPaths.put(outcome, new Path(outcome, score, path));<a name="line.177"></a>
<span class="sourceLineNo">178</span>            }<a name="line.178"></a>
<span class="sourceLineNo">179</span>          }<a name="line.179"></a>
<span class="sourceLineNo">180</span>        }<a name="line.180"></a>
<span class="sourceLineNo">181</span>        paths = maxPaths.values();<a name="line.181"></a>
<span class="sourceLineNo">182</span>      }<a name="line.182"></a>
<span class="sourceLineNo">183</span>    }<a name="line.183"></a>
<span class="sourceLineNo">184</span><a name="line.184"></a>
<span class="sourceLineNo">185</span>    // take the maximum of the final paths<a name="line.185"></a>
<span class="sourceLineNo">186</span>    return Collections.max(paths).outcomes;<a name="line.186"></a>
<span class="sourceLineNo">187</span>  }<a name="line.187"></a>
<span class="sourceLineNo">188</span><a name="line.188"></a>
<span class="sourceLineNo">189</span>  @Override<a name="line.189"></a>
<span class="sourceLineNo">190</span>  public List&lt;Map&lt;OUTCOME_TYPE, Double&gt;&gt; score(List&lt;List&lt;Feature&gt;&gt; features)<a name="line.190"></a>
<span class="sourceLineNo">191</span>      throws CleartkProcessingException {<a name="line.191"></a>
<span class="sourceLineNo">192</span>    throw new UnsupportedOperationException();<a name="line.192"></a>
<span class="sourceLineNo">193</span>  }<a name="line.193"></a>
<span class="sourceLineNo">194</span><a name="line.194"></a>
<span class="sourceLineNo">195</span>  public Map&lt;String, Type&gt; getTypeArguments(Class&lt;?&gt; genericType) {<a name="line.195"></a>
<span class="sourceLineNo">196</span>    if (genericType.equals(SequenceClassifier.class)) {<a name="line.196"></a>
<span class="sourceLineNo">197</span>      genericType = Classifier.class;<a name="line.197"></a>
<span class="sourceLineNo">198</span>    }<a name="line.198"></a>
<span class="sourceLineNo">199</span>    return ReflectionUtil.getTypeArguments(genericType, this.delegatedClassifier);<a name="line.199"></a>
<span class="sourceLineNo">200</span>  }<a name="line.200"></a>
<span class="sourceLineNo">201</span><a name="line.201"></a>
<span class="sourceLineNo">202</span>  private Map&lt;OUTCOME_TYPE, Double&gt; getScoredOutcomes(List&lt;Feature&gt; features, Path path)<a name="line.202"></a>
<span class="sourceLineNo">203</span>      throws CleartkProcessingException {<a name="line.203"></a>
<span class="sourceLineNo">204</span><a name="line.204"></a>
<span class="sourceLineNo">205</span>    // add the features from preceding outcomes<a name="line.205"></a>
<span class="sourceLineNo">206</span>    features = Lists.newArrayList(features);<a name="line.206"></a>
<span class="sourceLineNo">207</span>    if (path != null) {<a name="line.207"></a>
<span class="sourceLineNo">208</span>      List&lt;Object&gt; previousOutcomes = new ArrayList&lt;Object&gt;(path.outcomes);<a name="line.208"></a>
<span class="sourceLineNo">209</span>      for (OutcomeFeatureExtractor outcomeFeatureExtractor : this.outcomeFeatureExtractors) {<a name="line.209"></a>
<span class="sourceLineNo">210</span>        features.addAll(outcomeFeatureExtractor.extractFeatures(previousOutcomes));<a name="line.210"></a>
<span class="sourceLineNo">211</span>      }<a name="line.211"></a>
<span class="sourceLineNo">212</span>    }<a name="line.212"></a>
<span class="sourceLineNo">213</span><a name="line.213"></a>
<span class="sourceLineNo">214</span>    // get the scored outcomes for this instance<a name="line.214"></a>
<span class="sourceLineNo">215</span>    Map&lt;OUTCOME_TYPE, Double&gt; scoredOutcomes = this.delegatedClassifier.score(features);<a name="line.215"></a>
<span class="sourceLineNo">216</span>    if (scoredOutcomes.isEmpty()) {<a name="line.216"></a>
<span class="sourceLineNo">217</span>      throw new IllegalStateException("expected at least one scored outcome, found "<a name="line.217"></a>
<span class="sourceLineNo">218</span>          + scoredOutcomes);<a name="line.218"></a>
<span class="sourceLineNo">219</span>    }<a name="line.219"></a>
<span class="sourceLineNo">220</span>    return scoredOutcomes;<a name="line.220"></a>
<span class="sourceLineNo">221</span>  }<a name="line.221"></a>
<span class="sourceLineNo">222</span><a name="line.222"></a>
<span class="sourceLineNo">223</span>  private List&lt;OUTCOME_TYPE&gt; getTopOutcomes(Map&lt;OUTCOME_TYPE, Double&gt; scoredOutcomes) {<a name="line.223"></a>
<span class="sourceLineNo">224</span>    // get just the outcomes that fit within the stack<a name="line.224"></a>
<span class="sourceLineNo">225</span>    Ordering&lt;OUTCOME_TYPE&gt; ordering = Ordering.natural().onResultOf(<a name="line.225"></a>
<span class="sourceLineNo">226</span>        Functions.forMap(scoredOutcomes));<a name="line.226"></a>
<span class="sourceLineNo">227</span>    return ordering.greatestOf(scoredOutcomes.keySet(), this.stackSize);<a name="line.227"></a>
<span class="sourceLineNo">228</span>  }<a name="line.228"></a>
<span class="sourceLineNo">229</span><a name="line.229"></a>
<span class="sourceLineNo">230</span>  private class Path implements Comparable&lt;Path&gt; {<a name="line.230"></a>
<span class="sourceLineNo">231</span>    public OUTCOME_TYPE outcome;<a name="line.231"></a>
<span class="sourceLineNo">232</span><a name="line.232"></a>
<span class="sourceLineNo">233</span>    public double score;<a name="line.233"></a>
<span class="sourceLineNo">234</span><a name="line.234"></a>
<span class="sourceLineNo">235</span>    public Path parent;<a name="line.235"></a>
<span class="sourceLineNo">236</span><a name="line.236"></a>
<span class="sourceLineNo">237</span>    public List&lt;OUTCOME_TYPE&gt; outcomes;<a name="line.237"></a>
<span class="sourceLineNo">238</span><a name="line.238"></a>
<span class="sourceLineNo">239</span>    public Path(OUTCOME_TYPE outcome, double score, Path parent) {<a name="line.239"></a>
<span class="sourceLineNo">240</span>      this.outcome = outcome;<a name="line.240"></a>
<span class="sourceLineNo">241</span>      this.score = score;<a name="line.241"></a>
<span class="sourceLineNo">242</span>      this.parent = parent;<a name="line.242"></a>
<span class="sourceLineNo">243</span>      this.outcomes = Lists.newArrayList();<a name="line.243"></a>
<span class="sourceLineNo">244</span>      if (this.parent != null) {<a name="line.244"></a>
<span class="sourceLineNo">245</span>        this.outcomes.addAll(this.parent.outcomes);<a name="line.245"></a>
<span class="sourceLineNo">246</span>      }<a name="line.246"></a>
<span class="sourceLineNo">247</span>      this.outcomes.add(this.outcome);<a name="line.247"></a>
<span class="sourceLineNo">248</span>    }<a name="line.248"></a>
<span class="sourceLineNo">249</span><a name="line.249"></a>
<span class="sourceLineNo">250</span>    @Override<a name="line.250"></a>
<span class="sourceLineNo">251</span>    public String toString() {<a name="line.251"></a>
<span class="sourceLineNo">252</span>      ToStringHelper helper = Objects.toStringHelper(this);<a name="line.252"></a>
<span class="sourceLineNo">253</span>      helper.add("outcome", this.outcome);<a name="line.253"></a>
<span class="sourceLineNo">254</span>      helper.add("score", this.score);<a name="line.254"></a>
<span class="sourceLineNo">255</span>      helper.add("parent", this.parent);<a name="line.255"></a>
<span class="sourceLineNo">256</span>      return helper.toString();<a name="line.256"></a>
<span class="sourceLineNo">257</span>    }<a name="line.257"></a>
<span class="sourceLineNo">258</span><a name="line.258"></a>
<span class="sourceLineNo">259</span>    @Override<a name="line.259"></a>
<span class="sourceLineNo">260</span>    public int compareTo(Path that) {<a name="line.260"></a>
<span class="sourceLineNo">261</span>      return Doubles.compare(this.score, that.score);<a name="line.261"></a>
<span class="sourceLineNo">262</span>    }<a name="line.262"></a>
<span class="sourceLineNo">263</span>  }<a name="line.263"></a>
<span class="sourceLineNo">264</span>}<a name="line.264"></a>




























































</pre>
</div>
</body>
</html>
