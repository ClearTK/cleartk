<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
<title>Source code</title>
<link rel="stylesheet" type="text/css" href="../../../../../../stylesheet.css" title="Style">
</head>
<body>
<div class="sourceContainer">
<pre><span class="sourceLineNo">001</span>/** <a name="line.1"></a>
<span class="sourceLineNo">002</span> * Copyright (c) 2012, Regents of the University of Colorado <a name="line.2"></a>
<span class="sourceLineNo">003</span> * All rights reserved.<a name="line.3"></a>
<span class="sourceLineNo">004</span> * <a name="line.4"></a>
<span class="sourceLineNo">005</span> * Redistribution and use in source and binary forms, with or without<a name="line.5"></a>
<span class="sourceLineNo">006</span> * modification, are permitted provided that the following conditions are met:<a name="line.6"></a>
<span class="sourceLineNo">007</span> * <a name="line.7"></a>
<span class="sourceLineNo">008</span> * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. <a name="line.8"></a>
<span class="sourceLineNo">009</span> * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. <a name="line.9"></a>
<span class="sourceLineNo">010</span> * Neither the name of the University of Colorado at Boulder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. <a name="line.10"></a>
<span class="sourceLineNo">011</span> * <a name="line.11"></a>
<span class="sourceLineNo">012</span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"<a name="line.12"></a>
<span class="sourceLineNo">013</span> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE<a name="line.13"></a>
<span class="sourceLineNo">014</span> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE<a name="line.14"></a>
<span class="sourceLineNo">015</span> * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE<a name="line.15"></a>
<span class="sourceLineNo">016</span> * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR<a name="line.16"></a>
<span class="sourceLineNo">017</span> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF<a name="line.17"></a>
<span class="sourceLineNo">018</span> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS<a name="line.18"></a>
<span class="sourceLineNo">019</span> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN<a name="line.19"></a>
<span class="sourceLineNo">020</span> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)<a name="line.20"></a>
<span class="sourceLineNo">021</span> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE<a name="line.21"></a>
<span class="sourceLineNo">022</span> * POSSIBILITY OF SUCH DAMAGE. <a name="line.22"></a>
<span class="sourceLineNo">023</span> */<a name="line.23"></a>
<span class="sourceLineNo">024</span>package org.cleartk.classifier.feature.selection;<a name="line.24"></a>
<span class="sourceLineNo">025</span><a name="line.25"></a>
<span class="sourceLineNo">026</span>import java.io.BufferedReader;<a name="line.26"></a>
<span class="sourceLineNo">027</span>import java.io.BufferedWriter;<a name="line.27"></a>
<span class="sourceLineNo">028</span>import java.io.File;<a name="line.28"></a>
<span class="sourceLineNo">029</span>import java.io.FileReader;<a name="line.29"></a>
<span class="sourceLineNo">030</span>import java.io.FileWriter;<a name="line.30"></a>
<span class="sourceLineNo">031</span>import java.io.IOException;<a name="line.31"></a>
<span class="sourceLineNo">032</span>import java.net.URI;<a name="line.32"></a>
<span class="sourceLineNo">033</span>import java.util.ArrayList;<a name="line.33"></a>
<span class="sourceLineNo">034</span>import java.util.Collection;<a name="line.34"></a>
<span class="sourceLineNo">035</span>import java.util.List;<a name="line.35"></a>
<span class="sourceLineNo">036</span>import java.util.Locale;<a name="line.36"></a>
<span class="sourceLineNo">037</span>import java.util.Map;<a name="line.37"></a>
<span class="sourceLineNo">038</span>import java.util.Set;<a name="line.38"></a>
<span class="sourceLineNo">039</span><a name="line.39"></a>
<span class="sourceLineNo">040</span>import org.apache.uima.jcas.JCas;<a name="line.40"></a>
<span class="sourceLineNo">041</span>import org.apache.uima.jcas.tcas.Annotation;<a name="line.41"></a>
<span class="sourceLineNo">042</span>import org.cleartk.classifier.Feature;<a name="line.42"></a>
<span class="sourceLineNo">043</span>import org.cleartk.classifier.Instance;<a name="line.43"></a>
<span class="sourceLineNo">044</span>import org.cleartk.classifier.feature.extractor.CleartkExtractorException;<a name="line.44"></a>
<span class="sourceLineNo">045</span>import org.cleartk.classifier.feature.extractor.simple.SimpleFeatureExtractor;<a name="line.45"></a>
<span class="sourceLineNo">046</span>import org.cleartk.classifier.feature.selection.MutualInformationFeatureSelectionExtractor.CombineScoreMethod.CombineScoreFunction;<a name="line.46"></a>
<span class="sourceLineNo">047</span>import org.cleartk.classifier.feature.selection.MutualInformationFeatureSelectionExtractor.MutualInformationStats.ComputeFeatureScore;<a name="line.47"></a>
<span class="sourceLineNo">048</span>import org.cleartk.classifier.feature.transform.TransformableFeature;<a name="line.48"></a>
<span class="sourceLineNo">049</span><a name="line.49"></a>
<span class="sourceLineNo">050</span>import com.google.common.base.Function;<a name="line.50"></a>
<span class="sourceLineNo">051</span>import com.google.common.base.Joiner;<a name="line.51"></a>
<span class="sourceLineNo">052</span>import com.google.common.collect.Collections2;<a name="line.52"></a>
<span class="sourceLineNo">053</span>import com.google.common.collect.HashBasedTable;<a name="line.53"></a>
<span class="sourceLineNo">054</span>import com.google.common.collect.HashMultiset;<a name="line.54"></a>
<span class="sourceLineNo">055</span>import com.google.common.collect.Lists;<a name="line.55"></a>
<span class="sourceLineNo">056</span>import com.google.common.collect.Maps;<a name="line.56"></a>
<span class="sourceLineNo">057</span>import com.google.common.collect.Multiset;<a name="line.57"></a>
<span class="sourceLineNo">058</span>import com.google.common.collect.Ordering;<a name="line.58"></a>
<span class="sourceLineNo">059</span>import com.google.common.collect.Table;<a name="line.59"></a>
<span class="sourceLineNo">060</span><a name="line.60"></a>
<span class="sourceLineNo">061</span>/**<a name="line.61"></a>
<span class="sourceLineNo">062</span> * &lt;br&gt;<a name="line.62"></a>
<span class="sourceLineNo">063</span> * Copyright (c) 2012, Regents of the University of Colorado &lt;br&gt;<a name="line.63"></a>
<span class="sourceLineNo">064</span> * All rights reserved.<a name="line.64"></a>
<span class="sourceLineNo">065</span> * &lt;p&gt;<a name="line.65"></a>
<span class="sourceLineNo">066</span> * <a name="line.66"></a>
<span class="sourceLineNo">067</span> * Selects features via mutual information statistics between the features extracted from its<a name="line.67"></a>
<span class="sourceLineNo">068</span> * sub-extractor and the outcome values they are paired with in classification instances.<a name="line.68"></a>
<span class="sourceLineNo">069</span> * <a name="line.69"></a>
<span class="sourceLineNo">070</span> * @author Lee Becker<a name="line.70"></a>
<span class="sourceLineNo">071</span> * <a name="line.71"></a>
<span class="sourceLineNo">072</span> */<a name="line.72"></a>
<span class="sourceLineNo">073</span>public class MutualInformationFeatureSelectionExtractor&lt;OUTCOME_T&gt; extends<a name="line.73"></a>
<span class="sourceLineNo">074</span>    FeatureSelectionExtractor&lt;OUTCOME_T&gt; implements SimpleFeatureExtractor {<a name="line.74"></a>
<span class="sourceLineNo">075</span><a name="line.75"></a>
<span class="sourceLineNo">076</span>  /**<a name="line.76"></a>
<span class="sourceLineNo">077</span>   * Specifies how scores for each outcome should be combined/aggregated into a single score<a name="line.77"></a>
<span class="sourceLineNo">078</span>   */<a name="line.78"></a>
<span class="sourceLineNo">079</span>  public static enum CombineScoreMethod {<a name="line.79"></a>
<span class="sourceLineNo">080</span>    AVERAGE, // Average mutual information across all classes and take features with k-largest<a name="line.80"></a>
<span class="sourceLineNo">081</span>             // values<a name="line.81"></a>
<span class="sourceLineNo">082</span>    MAX; // Take highest mutual information value for each class<a name="line.82"></a>
<span class="sourceLineNo">083</span>    // MERGE, // Take k-largest mutual information values for each class and merge into a single<a name="line.83"></a>
<span class="sourceLineNo">084</span>    // collection - currently omitted because it requires a different extraction flow<a name="line.84"></a>
<span class="sourceLineNo">085</span><a name="line.85"></a>
<span class="sourceLineNo">086</span>    public abstract static class CombineScoreFunction&lt;OUTCOME_T&gt; implements<a name="line.86"></a>
<span class="sourceLineNo">087</span>        Function&lt;Map&lt;OUTCOME_T, Double&gt;, Double&gt; {<a name="line.87"></a>
<span class="sourceLineNo">088</span>    }<a name="line.88"></a>
<span class="sourceLineNo">089</span><a name="line.89"></a>
<span class="sourceLineNo">090</span>    public static class AverageScores&lt;OUTCOME_T&gt; extends CombineScoreFunction&lt;OUTCOME_T&gt; {<a name="line.90"></a>
<span class="sourceLineNo">091</span>      @Override<a name="line.91"></a>
<span class="sourceLineNo">092</span>      public Double apply(Map&lt;OUTCOME_T, Double&gt; input) {<a name="line.92"></a>
<span class="sourceLineNo">093</span>        Collection&lt;Double&gt; scores = input.values();<a name="line.93"></a>
<span class="sourceLineNo">094</span>        int size = scores.size();<a name="line.94"></a>
<span class="sourceLineNo">095</span>        double total = 0;<a name="line.95"></a>
<span class="sourceLineNo">096</span><a name="line.96"></a>
<span class="sourceLineNo">097</span>        for (Double score : scores) {<a name="line.97"></a>
<span class="sourceLineNo">098</span>          total += score;<a name="line.98"></a>
<span class="sourceLineNo">099</span>        }<a name="line.99"></a>
<span class="sourceLineNo">100</span>        return total / size;<a name="line.100"></a>
<span class="sourceLineNo">101</span>      }<a name="line.101"></a>
<span class="sourceLineNo">102</span>    }<a name="line.102"></a>
<span class="sourceLineNo">103</span><a name="line.103"></a>
<span class="sourceLineNo">104</span>    public static class MaxScores&lt;OUTCOME_T&gt; extends CombineScoreFunction&lt;OUTCOME_T&gt; {<a name="line.104"></a>
<span class="sourceLineNo">105</span>      @Override<a name="line.105"></a>
<span class="sourceLineNo">106</span>      public Double apply(Map&lt;OUTCOME_T, Double&gt; input) {<a name="line.106"></a>
<span class="sourceLineNo">107</span>        return Ordering.natural().max(input.values());<a name="line.107"></a>
<span class="sourceLineNo">108</span>      }<a name="line.108"></a>
<span class="sourceLineNo">109</span>    }<a name="line.109"></a>
<span class="sourceLineNo">110</span>  }<a name="line.110"></a>
<span class="sourceLineNo">111</span><a name="line.111"></a>
<span class="sourceLineNo">112</span>  /**<a name="line.112"></a>
<span class="sourceLineNo">113</span>   * Helper class for aggregating and computing mutual information statistics<a name="line.113"></a>
<span class="sourceLineNo">114</span>   */<a name="line.114"></a>
<span class="sourceLineNo">115</span>  public static class MutualInformationStats&lt;OUTCOME_T&gt; {<a name="line.115"></a>
<span class="sourceLineNo">116</span>    protected Multiset&lt;OUTCOME_T&gt; classCounts;<a name="line.116"></a>
<span class="sourceLineNo">117</span><a name="line.117"></a>
<span class="sourceLineNo">118</span>    protected Table&lt;String, OUTCOME_T, Integer&gt; classConditionalCounts;<a name="line.118"></a>
<span class="sourceLineNo">119</span><a name="line.119"></a>
<span class="sourceLineNo">120</span>    protected double smoothingCount;<a name="line.120"></a>
<span class="sourceLineNo">121</span><a name="line.121"></a>
<span class="sourceLineNo">122</span>    public MutualInformationStats(double smoothingCount) {<a name="line.122"></a>
<span class="sourceLineNo">123</span>      this.classCounts = HashMultiset.&lt;OUTCOME_T&gt; create();<a name="line.123"></a>
<span class="sourceLineNo">124</span>      this.classConditionalCounts = HashBasedTable.&lt;String, OUTCOME_T, Integer&gt; create();<a name="line.124"></a>
<span class="sourceLineNo">125</span>      this.smoothingCount += smoothingCount;<a name="line.125"></a>
<span class="sourceLineNo">126</span>    }<a name="line.126"></a>
<span class="sourceLineNo">127</span><a name="line.127"></a>
<span class="sourceLineNo">128</span>    public void update(String featureName, OUTCOME_T outcome, int occurrences) {<a name="line.128"></a>
<span class="sourceLineNo">129</span>      Integer count = this.classConditionalCounts.get(featureName, outcome);<a name="line.129"></a>
<span class="sourceLineNo">130</span>      if (count == null) {<a name="line.130"></a>
<span class="sourceLineNo">131</span>        count = 0;<a name="line.131"></a>
<span class="sourceLineNo">132</span>      }<a name="line.132"></a>
<span class="sourceLineNo">133</span>      this.classConditionalCounts.put(featureName, outcome, count + occurrences);<a name="line.133"></a>
<span class="sourceLineNo">134</span>      this.classCounts.add(outcome, occurrences);<a name="line.134"></a>
<span class="sourceLineNo">135</span>    }<a name="line.135"></a>
<span class="sourceLineNo">136</span><a name="line.136"></a>
<span class="sourceLineNo">137</span>    public double mutualInformation(String featureName, OUTCOME_T outcome) {<a name="line.137"></a>
<span class="sourceLineNo">138</span>      // notation index of 0 means false, 1 mean true<a name="line.138"></a>
<span class="sourceLineNo">139</span>      int[] featureCounts = new int[2];<a name="line.139"></a>
<span class="sourceLineNo">140</span>      int[] outcomeCounts = new int[2];<a name="line.140"></a>
<span class="sourceLineNo">141</span>      int[][] featureOutcomeCounts = new int[2][2];<a name="line.141"></a>
<span class="sourceLineNo">142</span><a name="line.142"></a>
<span class="sourceLineNo">143</span>      int n = this.classCounts.size();<a name="line.143"></a>
<span class="sourceLineNo">144</span>      featureCounts[1] = this.sum(this.classConditionalCounts.row(featureName).values());<a name="line.144"></a>
<span class="sourceLineNo">145</span>      featureCounts[0] = n - featureCounts[1];<a name="line.145"></a>
<span class="sourceLineNo">146</span>      outcomeCounts[1] = this.classCounts.count(outcome);<a name="line.146"></a>
<span class="sourceLineNo">147</span>      outcomeCounts[0] = n - outcomeCounts[1];<a name="line.147"></a>
<span class="sourceLineNo">148</span><a name="line.148"></a>
<span class="sourceLineNo">149</span>      featureOutcomeCounts[1][1] = this.classConditionalCounts.contains(featureName, outcome)<a name="line.149"></a>
<span class="sourceLineNo">150</span>          ? this.classConditionalCounts.get(featureName, outcome)<a name="line.150"></a>
<span class="sourceLineNo">151</span>          : 0;<a name="line.151"></a>
<span class="sourceLineNo">152</span>      featureOutcomeCounts[1][0] = featureCounts[1] - featureOutcomeCounts[1][1];<a name="line.152"></a>
<span class="sourceLineNo">153</span>      featureOutcomeCounts[0][1] = outcomeCounts[1] - featureOutcomeCounts[1][1];<a name="line.153"></a>
<span class="sourceLineNo">154</span>      featureOutcomeCounts[0][0] = n - featureCounts[1] - outcomeCounts[1]<a name="line.154"></a>
<span class="sourceLineNo">155</span>          + featureOutcomeCounts[1][1];<a name="line.155"></a>
<span class="sourceLineNo">156</span><a name="line.156"></a>
<span class="sourceLineNo">157</span>      double information = 0.0;<a name="line.157"></a>
<span class="sourceLineNo">158</span>      for (int nFeature = 0; nFeature &lt;= 1; nFeature++) {<a name="line.158"></a>
<span class="sourceLineNo">159</span>        for (int nOutcome = 0; nOutcome &lt;= 1; nOutcome++) {<a name="line.159"></a>
<span class="sourceLineNo">160</span>          featureOutcomeCounts[nFeature][nOutcome] += smoothingCount;<a name="line.160"></a>
<span class="sourceLineNo">161</span>          information += (double) featureOutcomeCounts[nFeature][nOutcome]<a name="line.161"></a>
<span class="sourceLineNo">162</span>              / (double) n<a name="line.162"></a>
<span class="sourceLineNo">163</span>              * Math.log(((double) n * featureOutcomeCounts[nFeature][nOutcome])<a name="line.163"></a>
<span class="sourceLineNo">164</span>                  / ((double) featureCounts[nFeature] * outcomeCounts[nOutcome]));<a name="line.164"></a>
<span class="sourceLineNo">165</span>        }<a name="line.165"></a>
<span class="sourceLineNo">166</span>      }<a name="line.166"></a>
<span class="sourceLineNo">167</span><a name="line.167"></a>
<span class="sourceLineNo">168</span>      return information;<a name="line.168"></a>
<span class="sourceLineNo">169</span>    }<a name="line.169"></a>
<span class="sourceLineNo">170</span><a name="line.170"></a>
<span class="sourceLineNo">171</span>    private int sum(Collection&lt;Integer&gt; values) {<a name="line.171"></a>
<span class="sourceLineNo">172</span>      int total = 0;<a name="line.172"></a>
<span class="sourceLineNo">173</span>      for (int v : values) {<a name="line.173"></a>
<span class="sourceLineNo">174</span>        total += v;<a name="line.174"></a>
<span class="sourceLineNo">175</span>      }<a name="line.175"></a>
<span class="sourceLineNo">176</span>      return total;<a name="line.176"></a>
<span class="sourceLineNo">177</span>    }<a name="line.177"></a>
<span class="sourceLineNo">178</span><a name="line.178"></a>
<span class="sourceLineNo">179</span>    public void save(URI outputURI) throws IOException {<a name="line.179"></a>
<span class="sourceLineNo">180</span>      File out = new File(outputURI);<a name="line.180"></a>
<span class="sourceLineNo">181</span>      BufferedWriter writer = null;<a name="line.181"></a>
<span class="sourceLineNo">182</span>      writer = new BufferedWriter(new FileWriter(out));<a name="line.182"></a>
<span class="sourceLineNo">183</span><a name="line.183"></a>
<span class="sourceLineNo">184</span>      // Write out header<a name="line.184"></a>
<span class="sourceLineNo">185</span>      writer.append("Mutual Information Data\n");<a name="line.185"></a>
<span class="sourceLineNo">186</span>      writer.append("Feature\t");<a name="line.186"></a>
<span class="sourceLineNo">187</span>      writer.append(Joiner.on("\t").join(this.classConditionalCounts.columnKeySet()));<a name="line.187"></a>
<span class="sourceLineNo">188</span>      writer.append("\n");<a name="line.188"></a>
<span class="sourceLineNo">189</span><a name="line.189"></a>
<span class="sourceLineNo">190</span>      // Write out Mutual Information data<a name="line.190"></a>
<span class="sourceLineNo">191</span>      for (String featureName : this.classConditionalCounts.rowKeySet()) {<a name="line.191"></a>
<span class="sourceLineNo">192</span>        writer.append(featureName);<a name="line.192"></a>
<span class="sourceLineNo">193</span>        for (OUTCOME_T outcome : this.classConditionalCounts.columnKeySet()) {<a name="line.193"></a>
<span class="sourceLineNo">194</span>          writer.append("\t");<a name="line.194"></a>
<span class="sourceLineNo">195</span>          writer.append(String.format(Locale.ROOT, "%f", this.mutualInformation(featureName, outcome)));<a name="line.195"></a>
<span class="sourceLineNo">196</span>        }<a name="line.196"></a>
<span class="sourceLineNo">197</span>        writer.append("\n");<a name="line.197"></a>
<span class="sourceLineNo">198</span>      }<a name="line.198"></a>
<span class="sourceLineNo">199</span>      writer.append("\n");<a name="line.199"></a>
<span class="sourceLineNo">200</span>      writer.append(this.classConditionalCounts.toString());<a name="line.200"></a>
<span class="sourceLineNo">201</span>      writer.close();<a name="line.201"></a>
<span class="sourceLineNo">202</span>    }<a name="line.202"></a>
<span class="sourceLineNo">203</span><a name="line.203"></a>
<span class="sourceLineNo">204</span>    public ComputeFeatureScore&lt;OUTCOME_T&gt; getScoreFunction(CombineScoreMethod combineScoreMethod) {<a name="line.204"></a>
<span class="sourceLineNo">205</span>      return new ComputeFeatureScore&lt;OUTCOME_T&gt;(this, combineScoreMethod);<a name="line.205"></a>
<span class="sourceLineNo">206</span>    }<a name="line.206"></a>
<span class="sourceLineNo">207</span><a name="line.207"></a>
<span class="sourceLineNo">208</span>    public static class ComputeFeatureScore&lt;OUTCOME_T&gt; implements Function&lt;String, Double&gt; {<a name="line.208"></a>
<span class="sourceLineNo">209</span><a name="line.209"></a>
<span class="sourceLineNo">210</span>      private MutualInformationStats&lt;OUTCOME_T&gt; stats;<a name="line.210"></a>
<span class="sourceLineNo">211</span><a name="line.211"></a>
<span class="sourceLineNo">212</span>      private CombineScoreFunction&lt;OUTCOME_T&gt; combineScoreFunction;<a name="line.212"></a>
<span class="sourceLineNo">213</span><a name="line.213"></a>
<span class="sourceLineNo">214</span>      public ComputeFeatureScore(<a name="line.214"></a>
<span class="sourceLineNo">215</span>          MutualInformationStats&lt;OUTCOME_T&gt; stats,<a name="line.215"></a>
<span class="sourceLineNo">216</span>          CombineScoreMethod combineMeasureType) {<a name="line.216"></a>
<span class="sourceLineNo">217</span>        this.stats = stats;<a name="line.217"></a>
<span class="sourceLineNo">218</span>        switch (combineMeasureType) {<a name="line.218"></a>
<span class="sourceLineNo">219</span>          case AVERAGE:<a name="line.219"></a>
<span class="sourceLineNo">220</span>            this.combineScoreFunction = new CombineScoreMethod.AverageScores&lt;OUTCOME_T&gt;();<a name="line.220"></a>
<span class="sourceLineNo">221</span>          case MAX:<a name="line.221"></a>
<span class="sourceLineNo">222</span>            this.combineScoreFunction = new CombineScoreMethod.MaxScores&lt;OUTCOME_T&gt;();<a name="line.222"></a>
<span class="sourceLineNo">223</span>        }<a name="line.223"></a>
<span class="sourceLineNo">224</span><a name="line.224"></a>
<span class="sourceLineNo">225</span>      }<a name="line.225"></a>
<span class="sourceLineNo">226</span><a name="line.226"></a>
<span class="sourceLineNo">227</span>      @Override<a name="line.227"></a>
<span class="sourceLineNo">228</span>      public Double apply(String featureName) {<a name="line.228"></a>
<span class="sourceLineNo">229</span>        Set&lt;OUTCOME_T&gt; outcomes = stats.classConditionalCounts.columnKeySet();<a name="line.229"></a>
<span class="sourceLineNo">230</span>        Map&lt;OUTCOME_T, Double&gt; featureOutcomeMI = Maps.newHashMap();<a name="line.230"></a>
<span class="sourceLineNo">231</span>        for (OUTCOME_T outcome : outcomes) {<a name="line.231"></a>
<span class="sourceLineNo">232</span>          featureOutcomeMI.put(outcome, stats.mutualInformation(featureName, outcome));<a name="line.232"></a>
<span class="sourceLineNo">233</span>        }<a name="line.233"></a>
<span class="sourceLineNo">234</span>        return this.combineScoreFunction.apply(featureOutcomeMI);<a name="line.234"></a>
<span class="sourceLineNo">235</span>      }<a name="line.235"></a>
<span class="sourceLineNo">236</span><a name="line.236"></a>
<span class="sourceLineNo">237</span>    }<a name="line.237"></a>
<span class="sourceLineNo">238</span><a name="line.238"></a>
<span class="sourceLineNo">239</span>  }<a name="line.239"></a>
<span class="sourceLineNo">240</span><a name="line.240"></a>
<span class="sourceLineNo">241</span>  public String nameFeature(Feature feature) {<a name="line.241"></a>
<span class="sourceLineNo">242</span>    return (feature.getValue() instanceof Number) ? feature.getName() : feature.getName() + ":"<a name="line.242"></a>
<span class="sourceLineNo">243</span>        + feature.getValue();<a name="line.243"></a>
<span class="sourceLineNo">244</span>  }<a name="line.244"></a>
<span class="sourceLineNo">245</span><a name="line.245"></a>
<span class="sourceLineNo">246</span>  protected boolean isTrained;<a name="line.246"></a>
<span class="sourceLineNo">247</span><a name="line.247"></a>
<span class="sourceLineNo">248</span>  private MutualInformationStats&lt;OUTCOME_T&gt; mutualInfoStats;<a name="line.248"></a>
<span class="sourceLineNo">249</span><a name="line.249"></a>
<span class="sourceLineNo">250</span>  private SimpleFeatureExtractor subExtractor;<a name="line.250"></a>
<span class="sourceLineNo">251</span><a name="line.251"></a>
<span class="sourceLineNo">252</span>  private int numFeatures;<a name="line.252"></a>
<span class="sourceLineNo">253</span><a name="line.253"></a>
<span class="sourceLineNo">254</span>  private CombineScoreMethod combineScoreMethod;<a name="line.254"></a>
<span class="sourceLineNo">255</span><a name="line.255"></a>
<span class="sourceLineNo">256</span>  private List&lt;String&gt; selectedFeatures;<a name="line.256"></a>
<span class="sourceLineNo">257</span><a name="line.257"></a>
<span class="sourceLineNo">258</span>  private double smoothingCount;<a name="line.258"></a>
<span class="sourceLineNo">259</span><a name="line.259"></a>
<span class="sourceLineNo">260</span>  public MutualInformationFeatureSelectionExtractor(String name, SimpleFeatureExtractor extractor) {<a name="line.260"></a>
<span class="sourceLineNo">261</span>    super(name);<a name="line.261"></a>
<span class="sourceLineNo">262</span>    this.init(extractor, CombineScoreMethod.MAX, 1.0, 10);<a name="line.262"></a>
<span class="sourceLineNo">263</span>  }<a name="line.263"></a>
<span class="sourceLineNo">264</span><a name="line.264"></a>
<span class="sourceLineNo">265</span>  public MutualInformationFeatureSelectionExtractor(<a name="line.265"></a>
<span class="sourceLineNo">266</span>      String name,<a name="line.266"></a>
<span class="sourceLineNo">267</span>      SimpleFeatureExtractor extractor,<a name="line.267"></a>
<span class="sourceLineNo">268</span>      int numFeatures) {<a name="line.268"></a>
<span class="sourceLineNo">269</span>    super(name);<a name="line.269"></a>
<span class="sourceLineNo">270</span>    this.init(extractor, CombineScoreMethod.MAX, 1.0, numFeatures);<a name="line.270"></a>
<span class="sourceLineNo">271</span>  }<a name="line.271"></a>
<span class="sourceLineNo">272</span><a name="line.272"></a>
<span class="sourceLineNo">273</span>  public MutualInformationFeatureSelectionExtractor(<a name="line.273"></a>
<span class="sourceLineNo">274</span>      String name,<a name="line.274"></a>
<span class="sourceLineNo">275</span>      SimpleFeatureExtractor extractor,<a name="line.275"></a>
<span class="sourceLineNo">276</span>      CombineScoreMethod combineMeasureType,<a name="line.276"></a>
<span class="sourceLineNo">277</span>      double smoothingCount,<a name="line.277"></a>
<span class="sourceLineNo">278</span>      int numFeatures) {<a name="line.278"></a>
<span class="sourceLineNo">279</span>    super(name);<a name="line.279"></a>
<span class="sourceLineNo">280</span>    this.init(extractor, combineMeasureType, smoothingCount, numFeatures);<a name="line.280"></a>
<span class="sourceLineNo">281</span>  }<a name="line.281"></a>
<span class="sourceLineNo">282</span><a name="line.282"></a>
<span class="sourceLineNo">283</span>  private void init(<a name="line.283"></a>
<span class="sourceLineNo">284</span>      SimpleFeatureExtractor extractor,<a name="line.284"></a>
<span class="sourceLineNo">285</span>      CombineScoreMethod method,<a name="line.285"></a>
<span class="sourceLineNo">286</span>      double smoothCount,<a name="line.286"></a>
<span class="sourceLineNo">287</span>      int n) {<a name="line.287"></a>
<span class="sourceLineNo">288</span>    this.subExtractor = extractor;<a name="line.288"></a>
<span class="sourceLineNo">289</span>    this.combineScoreMethod = method;<a name="line.289"></a>
<span class="sourceLineNo">290</span>    this.smoothingCount = smoothCount;<a name="line.290"></a>
<span class="sourceLineNo">291</span>    this.numFeatures = n;<a name="line.291"></a>
<span class="sourceLineNo">292</span>  }<a name="line.292"></a>
<span class="sourceLineNo">293</span><a name="line.293"></a>
<span class="sourceLineNo">294</span>  @Override<a name="line.294"></a>
<span class="sourceLineNo">295</span>  public List&lt;Feature&gt; extract(JCas view, Annotation focusAnnotation)<a name="line.295"></a>
<span class="sourceLineNo">296</span>      throws CleartkExtractorException {<a name="line.296"></a>
<span class="sourceLineNo">297</span><a name="line.297"></a>
<span class="sourceLineNo">298</span>    List&lt;Feature&gt; extracted = this.subExtractor.extract(view, focusAnnotation);<a name="line.298"></a>
<span class="sourceLineNo">299</span>    List&lt;Feature&gt; result = new ArrayList&lt;Feature&gt;();<a name="line.299"></a>
<span class="sourceLineNo">300</span>    if (this.isTrained) {<a name="line.300"></a>
<span class="sourceLineNo">301</span>      // Filter out selected features<a name="line.301"></a>
<span class="sourceLineNo">302</span>      result.addAll(Collections2.filter(extracted, this));<a name="line.302"></a>
<span class="sourceLineNo">303</span>    } else {<a name="line.303"></a>
<span class="sourceLineNo">304</span>      // We haven't trained this extractor yet, so just mark the existing features<a name="line.304"></a>
<span class="sourceLineNo">305</span>      // for future modification, by creating one uber-container feature<a name="line.305"></a>
<span class="sourceLineNo">306</span>      result.add(new TransformableFeature(this.name, extracted));<a name="line.306"></a>
<span class="sourceLineNo">307</span>    }<a name="line.307"></a>
<span class="sourceLineNo">308</span><a name="line.308"></a>
<span class="sourceLineNo">309</span>    return result;<a name="line.309"></a>
<span class="sourceLineNo">310</span>  }<a name="line.310"></a>
<span class="sourceLineNo">311</span><a name="line.311"></a>
<span class="sourceLineNo">312</span>  @Override<a name="line.312"></a>
<span class="sourceLineNo">313</span>  public void train(Iterable&lt;Instance&lt;OUTCOME_T&gt;&gt; instances) {<a name="line.313"></a>
<span class="sourceLineNo">314</span>    // aggregate statistics for all features and classes<a name="line.314"></a>
<span class="sourceLineNo">315</span>    this.mutualInfoStats = new MutualInformationStats&lt;OUTCOME_T&gt;(this.smoothingCount);<a name="line.315"></a>
<span class="sourceLineNo">316</span><a name="line.316"></a>
<span class="sourceLineNo">317</span>    for (Instance&lt;OUTCOME_T&gt; instance : instances) {<a name="line.317"></a>
<span class="sourceLineNo">318</span>      OUTCOME_T outcome = instance.getOutcome();<a name="line.318"></a>
<span class="sourceLineNo">319</span>      for (Feature feature : instance.getFeatures()) {<a name="line.319"></a>
<span class="sourceLineNo">320</span>        if (this.isTransformable(feature)) {<a name="line.320"></a>
<span class="sourceLineNo">321</span>          for (Feature untransformedFeature : ((TransformableFeature) feature).getFeatures()) {<a name="line.321"></a>
<span class="sourceLineNo">322</span>            mutualInfoStats.update(this.nameFeature(untransformedFeature), outcome, 1);<a name="line.322"></a>
<span class="sourceLineNo">323</span>          }<a name="line.323"></a>
<span class="sourceLineNo">324</span>        }<a name="line.324"></a>
<span class="sourceLineNo">325</span>      }<a name="line.325"></a>
<span class="sourceLineNo">326</span>    }<a name="line.326"></a>
<span class="sourceLineNo">327</span>    // Compute mutual information score for each feature<a name="line.327"></a>
<span class="sourceLineNo">328</span>    Set&lt;String&gt; featureNames = mutualInfoStats.classConditionalCounts.rowKeySet();<a name="line.328"></a>
<span class="sourceLineNo">329</span><a name="line.329"></a>
<span class="sourceLineNo">330</span>    this.selectedFeatures = Ordering.natural().onResultOf(<a name="line.330"></a>
<span class="sourceLineNo">331</span>        this.mutualInfoStats.getScoreFunction(this.combineScoreMethod)).reverse().immutableSortedCopy(<a name="line.331"></a>
<span class="sourceLineNo">332</span>        featureNames);<a name="line.332"></a>
<span class="sourceLineNo">333</span>    this.isTrained = true;<a name="line.333"></a>
<span class="sourceLineNo">334</span>  }<a name="line.334"></a>
<span class="sourceLineNo">335</span><a name="line.335"></a>
<span class="sourceLineNo">336</span>  @Override<a name="line.336"></a>
<span class="sourceLineNo">337</span>  public void save(URI uri) throws IOException {<a name="line.337"></a>
<span class="sourceLineNo">338</span>    if (!this.isTrained) {<a name="line.338"></a>
<span class="sourceLineNo">339</span>      throw new IOException("MutualInformationFeatureExtractor: Cannot save before training.");<a name="line.339"></a>
<span class="sourceLineNo">340</span>    }<a name="line.340"></a>
<span class="sourceLineNo">341</span>    File out = new File(uri);<a name="line.341"></a>
<span class="sourceLineNo">342</span>    BufferedWriter writer = new BufferedWriter(new FileWriter(out));<a name="line.342"></a>
<span class="sourceLineNo">343</span>    writer.append("CombineScoreType\t");<a name="line.343"></a>
<span class="sourceLineNo">344</span>    writer.append(this.combineScoreMethod.toString());<a name="line.344"></a>
<span class="sourceLineNo">345</span>    writer.append("\n");<a name="line.345"></a>
<span class="sourceLineNo">346</span><a name="line.346"></a>
<span class="sourceLineNo">347</span>    ComputeFeatureScore&lt;OUTCOME_T&gt; computeScore = this.mutualInfoStats.getScoreFunction(this.combineScoreMethod);<a name="line.347"></a>
<span class="sourceLineNo">348</span>    for (String feature : this.selectedFeatures) {<a name="line.348"></a>
<span class="sourceLineNo">349</span>      writer.append(String.format(Locale.ROOT, "%s\t%f\n", feature, computeScore.apply(feature)));<a name="line.349"></a>
<span class="sourceLineNo">350</span>    }<a name="line.350"></a>
<span class="sourceLineNo">351</span><a name="line.351"></a>
<span class="sourceLineNo">352</span>    writer.close();<a name="line.352"></a>
<span class="sourceLineNo">353</span><a name="line.353"></a>
<span class="sourceLineNo">354</span>  }<a name="line.354"></a>
<span class="sourceLineNo">355</span><a name="line.355"></a>
<span class="sourceLineNo">356</span>  @Override<a name="line.356"></a>
<span class="sourceLineNo">357</span>  public void load(URI uri) throws IOException {<a name="line.357"></a>
<span class="sourceLineNo">358</span>    this.selectedFeatures = Lists.newArrayList();<a name="line.358"></a>
<span class="sourceLineNo">359</span>    File in = new File(uri);<a name="line.359"></a>
<span class="sourceLineNo">360</span>    BufferedReader reader = new BufferedReader(new FileReader(in));<a name="line.360"></a>
<span class="sourceLineNo">361</span><a name="line.361"></a>
<span class="sourceLineNo">362</span>    // First line specifies the combine utility type<a name="line.362"></a>
<span class="sourceLineNo">363</span>    this.combineScoreMethod = CombineScoreMethod.valueOf(reader.readLine().split("\\t")[1]);<a name="line.363"></a>
<span class="sourceLineNo">364</span><a name="line.364"></a>
<span class="sourceLineNo">365</span>    // The rest of the lines are feature + selection scores<a name="line.365"></a>
<span class="sourceLineNo">366</span>    String line = null;<a name="line.366"></a>
<span class="sourceLineNo">367</span>    int n = 0;<a name="line.367"></a>
<span class="sourceLineNo">368</span>    while ((line = reader.readLine()) != null &amp;&amp; n &lt; this.numFeatures) {<a name="line.368"></a>
<span class="sourceLineNo">369</span>      String[] featureValuePair = line.split("\\t");<a name="line.369"></a>
<span class="sourceLineNo">370</span>      this.selectedFeatures.add(featureValuePair[0]);<a name="line.370"></a>
<span class="sourceLineNo">371</span>      n++;<a name="line.371"></a>
<span class="sourceLineNo">372</span>    }<a name="line.372"></a>
<span class="sourceLineNo">373</span><a name="line.373"></a>
<span class="sourceLineNo">374</span>    reader.close();<a name="line.374"></a>
<span class="sourceLineNo">375</span>    this.isTrained = true;<a name="line.375"></a>
<span class="sourceLineNo">376</span>  }<a name="line.376"></a>
<span class="sourceLineNo">377</span><a name="line.377"></a>
<span class="sourceLineNo">378</span>  @Override<a name="line.378"></a>
<span class="sourceLineNo">379</span>  public boolean apply(Feature feature) {<a name="line.379"></a>
<span class="sourceLineNo">380</span>    return this.selectedFeatures.contains(this.nameFeature(feature));<a name="line.380"></a>
<span class="sourceLineNo">381</span>  }<a name="line.381"></a>
<span class="sourceLineNo">382</span><a name="line.382"></a>
<span class="sourceLineNo">383</span>  public final List&lt;String&gt; getSelectedFeatures() {<a name="line.383"></a>
<span class="sourceLineNo">384</span>    return this.selectedFeatures;<a name="line.384"></a>
<span class="sourceLineNo">385</span>  }<a name="line.385"></a>
<span class="sourceLineNo">386</span><a name="line.386"></a>
<span class="sourceLineNo">387</span>}<a name="line.387"></a>




























































</pre>
</div>
</body>
</html>
